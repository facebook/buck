{namespace buck.autodeps}

/***/
{template .soyweb}
  {call buck.page}
    {param title: 'buck autodeps' /}
    {param prettify: true /}
    {param description}

    {/param}
    {param content}

{call buck.command}

{param overview}
<h1 class="warning">THIS COMMAND IS HIGHLY EXPERIMENTAL AND IS SUBJECT TO CHANGE WITHOUT NOTICE!</h1>

<blockquote>
Normally, we would not publicly document a feature of Buck that is in such early stages; however,
because we are using it in Buck itself, contributors need to know how it works.
</blockquote>

<h2>tl;dr</h2>

We have an experimental feature to auto-generate the <code>deps</code> and{sp}
<code>exported_deps</code> for the following rules:

<ul>
  // Don't mention android_library() yet because we don't have a story around
  // automatically adding android_resource() dependencies.
  // <li>{call buck.android_library /}
  <li>{call buck.java_library /}
  <li>{call buck.java_test /}
</ul>

<h2>The Problem</h2>

<p>
Maintaining your <code>deps</code> by hand in a <code>BUCK</code> file can be tedious.
In practice, most programming languages have an existing mechanism for expressing dependencies
in the source code, so what appears in your <code>deps</code> often duplicates that information.
For example, in Java, there is often a straightforward mapping between
your <code>import</code> statements and your <code>deps</code>.

<p>
To make matters worse, the tools that you use to write in your programming language often help
keep the dependencies in your code up to date, but do not help with your <code>BUCK</code> files.
Let's consider Java, which has many great IDEs that support all sorts of far-reaching
refactoring operations. Although the IDE may make it simple to do something like extract an
interface for a class, it will not help you split the new interface into its
own <code>java_library()</code> rule in Buck and update all of your <code>deps</code>, as appropriate.

<p>
This is bad. Particularly because developers frequently work around this in one of two ways:
<ul>
  <li>They let small modules grow into large ones out of concern that the cost of having to
      update so many <code>BUCK</code> files outweights the benefit of having smaller modules.
  <li>They split up the <code>srcs</code> of a large library, but copy-paste
      the <code>deps</code>. The result is that the resulting libraries end up with
      superfluous items in the <code>deps</code>, which can slow down build times.
</ul>

Developers should not have to choose between using the full power of their IDE and
fast build times.

<h2>Our Experimental Solution</h2>

<p>
The idea is that you can opt-in to letting Buck auto-generate the <code>deps</code> of
individual <code>java_library()</code> and <code>java_test()</code> rules by adding
the argument <code>autodeps = True</code> to the rule. In practice, a rule
with <code>autodeps = True</code> should almost always have empty arguments
for <code>deps</code> and <code>exported_deps</code>.

<p>
After you have added <code>autodeps = True</code> and you have deleted your <code>deps</code>,
the next step is to run <code>buck autodeps</code>. For every <code>BUCK</code> file
with an <code>autodeps = True</code>, a <code>BUCK.autodeps</code> file will be
generated alongside of it. The <code>BUCK.autodeps</code> file contains the list of
autogenerated dependencies, as well as a SHA-1 signature of its contents.
(Signature checking is currently disabled, but we plan to turn it on by default once we
believe <code>buck autodeps</code> is reliable.)

<p>
Now when Buck parses a <code>BUCK</code> file for building, it looks alongside it for the presence
of a <code>BUCK.autodeps</code> file. If present, it uses it to amend the <code>deps</code> and{sp}
<code>exported_deps</code> of the rules declared therein. <strong>As things work today</strong>, we
recommend checking in your <code>BUCK.autodeps</code> files. Admittedly, checking in generated
code is gross, causes merge conflicts, etc. However, until we are sure
that <code>buck autodeps</code> is performant, checking in the files ensures that someone who
checks out the code can build right away without waiting for <code>buck autodeps</code> to run.
Also, in the early stages of <code>buck autodeps</code>, it makes it easier to identify when{sp}
<code>buck autodeps</code> has decided to change what it generates. (Such changes should be
sanity-checked against changes in the <code>.java</code> code that accompany the changes
to <code>BUCK.autodeps</code> files.)

<p>
As you can see from the <a href="#troubleshooting">Troubleshooting</a> section,
there are some ways that <code>buck autodeps</code> can end up doing the wrong thing.
Our goal is to make sure we provide you with an escape hatch if you run into trouble.

<h2>How Required and Provided Symbols Are Extracted</h2>

<p>
When <code>buck autodeps</code> is run, Buck only looks at
non-generated <code>srcs</code> for the rule and parses (but does
not compile) the <code>.java</code> files. The goal of parsing is to extract symbols
and put them in the following buckets:

<ul>
  <li><strong>required symbols</strong> are symbols that must be on the <code>$CLASSPATH</code>{sp}
    when the <code>srcs</code> are compiled.
  <li><strong>exported symbols</strong> are also symbols that must be on
    the <code>$CLASSPATH</code> when the <code>srcs</code> are compiled, but have the additional
    constraint that they need to be on the <code>$CLASSPATH</code> when someone else depends
    on this rule. (Roughly, they correspond to types that are visible via the non-private API
    of the file.)
  <li><strong>provided symbols</strong> are the types of the <code>.class</code> files when the
    rule is built (i.e., the types that the rule provides).
</ul>

<p>
Here is a simple example:

<p>
{literal}<pre class="prettyprint lang-java">
package com.example;

import com.example.foo.Bar;

class Foo extends Bar {
  private final IBazFactory factory = new BazFactory();

  public Baz makeBaz() throws BazFactoryException {
    return factory.newBaz();
  }
}
</pre>{/literal}

In this example:

<ul>
  <li>The required symbols are <code>com.example.BazFactory</code> and{sp}
    <code>com.example.IBazFactory</code>. They are needed for compilation, but do not appear in the
    non-private API of <code>Foo</code>.
  <li>The exported symbols are <code>com.example.foo.Bar</code>, <code>com.example.Baz</code>,
    and <code>com.example.BazFactoryException</code>.
  <li>The lone provided symbol is <code>com.example.Foo</code>.
</ul>

<p>
In the absence of compilation, some expressions are ambiguous when it comes to extracting symbols.
Buck assumes that you are following traditional Java naming
conventions when deciding how to resolve an ambiguity. For example, if you have
the following code:

<p>
{literal}<pre class="prettyprint lang-java">
Object obj = com.foo.Bar.baz();
</pre>{/literal}

<p>
Buck assumes that this is a fully qualified reference to the class <code>com.foo.Bar</code> with
a static method named <code>baz()</code>. It is also possible for this to refer to a
class whose fully-qualified name is <code>com.foo</code> with a field named <code>Bar</code> with
a static method named <code>baz()</code>. However, the latter would violate standard Java
naming conventions because <code>foo</code> should start with an uppercase letter if it
identifies a class, so Buck will assume the former, instead.
As a result, Buck adds <code>com.foo.Bar</code> to the set of required symbols for the
build rule that contains this Java code.

<p>
Similarly, generics can also introduce an ambiguity when parsing. For example, consider the
following code:

<p>
{literal}<pre class="prettyprint lang-java">
package com.example;

class Foo&lt;T> {}
</pre>{/literal}

<p>
Without knowing all types that are available in <code>com.example</code>, it is impossible
for <code>buck autodeps</code> to know whether <code>T</code> is a generic type or a
reference to an existing type, <code>com.example.T</code>.

<p>
Buck's heuristic for resolving this ambiguity is: if the name of the type is in all caps,
it is assumed to refer to a generic type. Admittedly, there are some types in the JDK
itself that violate this heuristic, such as <code>java.net.URL</code>. If this is an
issue, the rule that provides or uses the type will have to be explicitly added
to <code>deps</code> or <code>exported_deps</code>, as appropriate.

<p>
The class that is responsible for extracting these symbols from the <code>.java</code> files is{sp}
<a href="https://github.com/facebook/buck/blob/master/src/com/facebook/buck/jvm/java/JavaFileParser.java">JavaFileParser.java</a>,
and the corresponding unit test is{sp}
<a href="https://github.com/facebook/buck/blob/master/test/com/facebook/buck/jvm/java/JavaFileParserTest.java">JavaFileParserTest.java</a>.
{sp}<strong>It is quite possible that there are edge cases that this code is missing, so feel free
to send out a pull request with a unit test to improve the existing heuristics.</strong>

<p>
Finally, there are some types that may be provided by a {call buck.java_library /} rule,
but cannot be determined from parsing the <code>srcs</code> because they are provided
dynamically. (For example, using a {call buck.genrule /} to generate one of the <code>srcs</code>).
In this case, you must specify the names of the generated types via
the <code>generated_symbols</code> argument to {call buck.java_library /}.

<h2>How Autodeps Are Assigned</h2>

<p>
The process of auto-generating dependencies is pretty straightforward. After the parse phase,
Buck has a set of provided, exported, and required symbols for all rules of the following
types in your project (regardless of the rule's <code>autodeps</code> argument):

<ul>
  <li>{call buck.android_library /}
  <li>{call buck.java_library /}
  <li>{call buck.java_test /}
  <li>{call buck.prebuilt_jar /}
</ul>

<p>
(Note that, at the time of this writing, {call buck.android_resource /} is not in this list.)

<p>
For each required and exported symbol for a rule with <code>autodeps = True</code>, an entry in
a <code>BUCK.autodeps</code> file is generated as follows (the build target is added
to <code>deps</code> for required symbols and to <code>exported_deps</code> for exported symbols):

<ul>
  <li>If there is a prefix match in <code>.buckconfig</code> under
      the <code>java-package-mappings</code> option
      in the <code>[autodeps]</code> section, the corresponding build target is used.
  <li>If there is exactly one visible provider of the symbol, its build target is used.
  <li>If there are multiple visible providers, then a warning is printed.
      The developer is responsible for deciding how to resolve the warning.
      (Often, this is done by restricting the visibility of all but one provider.)
  <li>If there are zero [visible] providers, then a check is done for providers
      that appear in the <code>exported_deps</code> of other visible rules.
  <ul>
    <li>If there is exactly one, its build target is used.
    <li>If there is more than one, a warning is printed.
    <li>If there are zero, nothing is printed and Buck assumes that the user will
        take action if/when compilation fails, as a result. It's possible that this
        is an edge case where the user has to hardcode something in the
        rule's <code>deps</code> or <code>exported_deps</code>.
  </ul>
</ul>

The results are cleaned up such that <code>deps</code> and <code>exported_deps</code> are
disjoint sets for each build rule.

<h2 id="troubleshooting">Troubleshooting</h2>

When <code>buck autodeps</code> does not generate the correct dependencies,
there are several things you can do to fix it, depending on the problem.
First you must determine whether the dependencies
are <em>underspecified</em> or <em>overspecified</em>.

<h3>Fixing Underspecified Deps</h3>

<p>
There are several ways to solve this problem.

<p>
The quickest and dirtiest solution is to add the missing build target manually to
the <code>deps</code> argument of your build rule. This is the least desirable solution
because if your library evolves to the point where it no longer needs that
dependency, you will probably never discover the change and you will be
over-depping, slowing down your build times. This may be a reasonable thing to do
locally while you are developing, but you should clean this up before you commit
your change. (At least add a <code>TODO</code> or a <code>FIXME</code> so you have
some chance of coming back to the problem in the future and fixing it.)

<p>
Note that we managed to add support for <code>autodeps = True</code> to
all of the {call buck.java_library /} and {call buck.java_test /} rules in Buck without resorting
to adding hardcoded <code>deps</code>. There were several cases where we
decided to use the default of <code>autodeps = False</code> where we had sensitive
code where it would have been an error for it to take on any dependencies.
We would generally include a comment inside the empty <code>deps</code> array with
a reason explaining why we do not want to auto-generate dependencies for that rule.

<p>
We don't load classes via reflection in Buck, but if we did, that would also be
a legitimate case for manually adding something to your deps. Another case was
a dependency on a {call buck.java_library /} that contained only resources, so there
was no way for Buck to statically determine that dependency.

<p>
Although <code>buck autodeps</code> is working well for Buck, your code may exercise a
valid case that Buck does not cover. See the note above about verifying Buck's logic in{sp}
<a href="https://github.com/facebook/buck/blob/master/src/com/facebook/buck/jvm/java/JavaFileParser.java">JavaFileParser.java</a>
{sp}to ensure it is doing the right thing.

<h3>Fixing Overspecified Deps</h3>

<p>
If <code>buck autodeps</code> introduces dependencies that you did not want, then you have
two options:

<ul>
  <li>Modify the visibility of the unwanted rule such that it is not visible to the rule
      that is ending up with it in its <code>deps</code>. The <code>buck autodeps</code> command
      will not include rules that it knows are not visible to the target rule.
      (The one exception is when there is an explicit mapping in your <code>.buckconfig</code> file.
      Buck does not check the visibility when applying such mappings.)
  <li>Add the build target of the unwanted dependency to the <code>provided_deps</code> of
      your rule that is ending up with the unwanted dependency.
</ul>

{/param} // overview
{/call} // buck.command

    {/param}  // content
  {/call} // buck.page
{/template}

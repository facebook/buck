/*
 * Copyright 2019-present Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */
package com.facebook.buck.core.rules.providers.impl;

import com.facebook.buck.core.rules.providers.Provider;
import com.facebook.buck.core.rules.providers.annotations.ImmutableInfo;
import com.facebook.buck.core.starlark.compatible.BuckStarlarkFunction;
import com.facebook.buck.core.starlark.compatible.MethodLookup;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Lists;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Parameter;
import java.util.List;
import org.immutables.value.Value;

/**
 * A {@link Provider} for a {@link com.facebook.buck.core.rules.providers.ProviderInfo} that is
 * declared in java. The provider is auto generated by any {@link BuiltInProviderInfo} that is
 * declared via reflection.
 *
 * @param <T> the specific type of the {@link com.facebook.buck.core.rules.providers.ProviderInfo}
 *     this instance of the provider creates.
 */
public class BuiltInProvider<T extends BuiltInProviderInfo<T>> extends BuckStarlarkFunction
    implements Provider<T> {

  protected final BuiltInKey<T> key;
  private final Constructor<? extends T> infoConstructor;

  private BuiltInProvider(
      Class<? extends T> infoClass,
      Constructor<? extends T> infoConstructor,
      List<String> infoApiFields) {
    super(infoClass.getSimpleName(), infoConstructor, infoApiFields);
    this.key = ImmutableBuiltInKey.of(infoClass);
    this.infoConstructor = infoConstructor;
    this.infoConstructor.setAccessible(true);
  }

  /**
   * @param infoClass the generated immutable class containing the API of the {@link
   *     com.facebook.buck.core.rules.providers.ProviderInfo} we want to expose.
   * @param <U> the type of the specific {@link BuiltInProviderInfo} this provider is for.
   * @return a {@link BuiltInProvider} that identifies and can be used to construct the {@link
   *     BuiltInProviderInfo}
   */
  public static <U extends BuiltInProviderInfo<U>> BuiltInProvider<U> of(
      Class<? extends U> infoClass) {
    // TODO: We'll want to probably eventually do annotation processors to make these compile time
    // errors.
    Class<U> infoApiClass = BuiltInProviderClassUtilities.findDeclaringClass(infoClass);
    ImmutableInfo info = infoApiClass.getAnnotation(ImmutableInfo.class);
    ImmutableMap<String, Method> methodMap = MethodLookup.getMethods(infoApiClass);
    ImmutableList<String> argNames = ImmutableList.copyOf(info.args());
    List<Class<?>> types =
        Lists.transform(
            argNames,
            name ->
                Preconditions.checkNotNull(
                        methodMap.get(name),
                        "%s should have a public getter method %s",
                        infoApiClass,
                        name)
                    .getReturnType());

    try {
      return new BuiltInProvider<>(
          infoApiClass, findConstructor(infoClass, types), ImmutableList.copyOf(info.args()));
    } catch (NoSuchMethodException e) {
      throw new IllegalArgumentException(
          String.format(
              "Infos must have a public constructor that initializes all struct values but %s doesn't. Expected constructor parameters %s",
              infoClass, types));
    }
  }

  @SuppressWarnings("unchecked")
  private static <U extends BuiltInProviderInfo<U>> Constructor<U> findConstructor(
      Class<? extends U> infoClass, List<Class<?>> values) throws NoSuchMethodException {
    try {
      return (Constructor<U>) infoClass.getConstructor(values.toArray(new Class[] {}));
    } catch (NoSuchMethodException e) {
      // no direct matching constructor. Now we check if there is a compatible constructor since
      // Immutables can generate constructors that take the Iterable type instead of the specific
      // Set/List types

      Constructor<?> found = null;
      Constructor<?>[] constructors = infoClass.getConstructors();
      outer:
      for (int i = 0; i < constructors.length; i++) {
        Parameter[] parameters = constructors[i].getParameters();
        for (int j = 0; j < parameters.length; j++) {
          if (!parameters[j].getType().isAssignableFrom(values.get(j))) {
            // not the right constructor. Go to the next constructor in outer loop
            continue outer;
          }
        }
        if (found != null) {
          throw new IllegalArgumentException(
              String.format(
                  "Multiple constructors on class %s matches signature with type of %s",
                  infoClass, values));
        }

        found = constructors[i];
      }
      if (found == null) {
        throw new NoSuchMethodException();
      }
      return (Constructor<U>) found;
    }
  }

  /**
   * Constructs the info.
   *
   * @param args the args to the {@link BuiltInProviderInfo} being constructed
   * @return the info itself
   */
  public final T createInfo(Object... args)
      throws IllegalAccessException, InvocationTargetException, InstantiationException {
    return infoConstructor.newInstance(args);
  }

  @Override
  public Key<T> getKey() {
    return key;
  }

  /**
   * The key for a {@link BuiltInProvider} which is unique per provider that generates the same info
   *
   * @param <U> the type of the {@link BuiltInProviderInfo}
   */
  @Value.Immutable(copy = false, builder = false, prehash = true)
  @Value.Style(visibility = Value.Style.ImplementationVisibility.PACKAGE)
  public abstract static class BuiltInKey<U> implements Provider.Key<U> {
    @Value.Parameter
    abstract Class<?> getInfoClass();

    @Override
    public String toString() {
      return getInfoClass().getSimpleName();
    }
  }
}

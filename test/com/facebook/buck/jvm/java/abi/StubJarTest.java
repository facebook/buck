/*
 * Copyright 2014-present Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

package com.facebook.buck.jvm.java.abi;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeThat;

import com.facebook.buck.event.DefaultBuckEventBus;
import com.facebook.buck.io.filesystem.ProjectFilesystem;
import com.facebook.buck.io.filesystem.TestProjectFilesystems;
import com.facebook.buck.io.filesystem.impl.DefaultProjectFilesystemFactory;
import com.facebook.buck.jvm.java.JarDumper;
import com.facebook.buck.jvm.java.JavacEventSinkToBuckEventBusBridge;
import com.facebook.buck.jvm.java.testutil.compiler.CompilerTreeApiParameterized;
import com.facebook.buck.jvm.java.testutil.compiler.TestCompiler;
import com.facebook.buck.model.BuildId;
import com.facebook.buck.util.sha1.Sha1HashCode;
import com.facebook.buck.util.timing.FakeClock;
import com.facebook.buck.util.unarchive.ArchiveFormat;
import com.facebook.buck.util.unarchive.ExistingFileMode;
import com.facebook.buck.util.zip.DeterministicManifest;
import com.facebook.buck.util.zip.JarBuilder;
import com.google.common.base.Joiner;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.io.CharStreams;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;
import java.util.concurrent.Callable;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.stream.Collectors;
import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Processor;
import javax.annotation.processing.RoundEnvironment;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.TypeElement;
import javax.tools.Diagnostic.Kind;
import org.hamcrest.Matchers;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.objectweb.asm.ClassReader;

// The stub source is easier to read as long lines, so...
// CHECKSTYLE.OFF: LineLengthCheck
@RunWith(CompilerTreeApiParameterized.class)
public class StubJarTest {
  // Test a stub generated by stripping a full jar
  private static final String MODE_JAR_BASED = "JAR_BASED";

  // Test a stub generated from source
  private static final String MODE_SOURCE_BASED = "SOURCE_BASED";

  // Test a stub generated from source, with dependencies missing
  private static final String MODE_SOURCE_BASED_MISSING_DEPS = "SOURCE_BASED_MISSING_DEPS";

  @Parameterized.Parameter public String testingMode;

  @Parameterized.Parameters(name = "{0}")
  public static Object[] getParameters() {
    return new Object[] {MODE_JAR_BASED, MODE_SOURCE_BASED, MODE_SOURCE_BASED_MISSING_DEPS};
  }

  private static final ImmutableSortedSet<Path> EMPTY_CLASSPATH = ImmutableSortedSet.of();

  @Rule public TemporaryFolder temp = new TemporaryFolder();

  private Tester tester = new Tester();

  private ProjectFilesystem filesystem;

  @Before
  public void createTempFilesystem() throws IOException {
    File out = temp.newFolder();
    filesystem = TestProjectFilesystems.createProjectFilesystem(out.toPath());
  }

  @Test
  public void emptyClass() throws IOException {
    tester
        .setSourceFile("A.java", "package com.example.buck; public class A {}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .createAndCheckStubJar()
        .addStubJarToClasspath()
        .setSourceFile("B.java", "package com.example.buck; public class B extends A {}")
        .testCanCompile();
  }

  @Test
  public void emptyClassWithAnnotation() throws IOException {
    tester
        .setSourceFile("A.java", "package com.example.buck; @Deprecated public class A {}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// DEPRECATED",
            "// access flags 0x20021",
            "public class com/example/buck/A {",
            "",
            "",
            "  @Ljava/lang/Deprecated;()",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void testDeprecatedViaDocComment() throws IOException {
    tester
        .setSourceFile(
            "A.java", "package com.example.buck;", "/** @deprecated */", "public class A { }")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// DEPRECATED",
            "// access flags 0x20021",
            "public class com/example/buck/A {",
            "",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void classWithTwoMethods() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  public String toString() { return null; }",
            "  public void eatCake() {}",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "",
            "  // access flags 0x1",
            "  public toString()Ljava/lang/String;",
            "",
            "  // access flags 0x1",
            "  public eatCake()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void stubsOverloadedMethods() throws IOException {
    tester
        .setSourceFile(
            "Dependency.java", "package com.example.buck;", "public class Dependency {", "}")
        .createStubJar()
        .addStubJarToClasspath()
        .setSourceFile(
            "Dependency2.java", "package com.example.buck;", "public class Dependency2 {", "}")
        .createStubJar()
        .addStubJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  public void overloaded(Dependency d) { }",
            "  public void overloaded(String s) { }",
            "  public void overloaded(Dependency2 d) { }",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "",
            "  // access flags 0x1",
            "  public overloaded(Lcom/example/buck/Dependency;)V",
            "",
            "  // access flags 0x1",
            "  public overloaded(Ljava/lang/String;)V",
            "",
            "  // access flags 0x1",
            "  public overloaded(Lcom/example/buck/Dependency2;)V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void preservesThrowsClauses() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  public void throwSomeStuff() throws Exception, Throwable {}",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "",
            "  // access flags 0x1",
            "  public throwSomeStuff()V throws java/lang/Exception java/lang/Throwable ",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void preservesThrowsClausesWithTypeVars() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "import java.io.IOException;",
            "public class A {",
            "  public <E extends IOException> void throwSomeStuff() throws E {}",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "",
            "  // access flags 0x1",
            "  // signature <E:Ljava/io/IOException;>()V^TE;",
            "  // declaration: void throwSomeStuff<E extends java.io.IOException>() throws E",
            "  public throwSomeStuff()V throws java/io/IOException ",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void genericClassSignaturesShouldBePreserved() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A<T> {",
            "  public T get(String key) { return null; }",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "// signature <T:Ljava/lang/Object;>Ljava/lang/Object;",
            "// declaration: com/example/buck/A<T>",
            "public class com/example/buck/A {",
            "",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "",
            "  // access flags 0x1",
            "  // signature (Ljava/lang/String;)TT;",
            "  // declaration: T get(java.lang.String)",
            "  public get(Ljava/lang/String;)Ljava/lang/Object;",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void genericTypeBoundsShouldBePreserved() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A<T extends java.util.ArrayList, U extends CharSequence, V extends T> {",
            "  public T get(U u, V v) { return null; }",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "// signature <T:Ljava/util/ArrayList;U::Ljava/lang/CharSequence;V:TT;>Ljava/lang/Object;",
            "// declaration: com/example/buck/A<T extends java.util.ArrayList, U extends java.lang.CharSequence, VT>",
            "public class com/example/buck/A {",
            "",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "",
            "  // access flags 0x1",
            "  // signature (TU;TV;)TT;",
            "  // declaration: T get(U, V)",
            "  public get(Ljava/lang/CharSequence;Ljava/util/ArrayList;)Ljava/util/ArrayList;",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void elementsInStubCorrectlyInOrder() throws IOException {
    // Fields and methods should stub in order
    // Inner classes should stub in reverse
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "    boolean first;",
            "    float second;",
            "  public void foo() { }",
            "  public class B { }",
            "  public class C { }",
            "  public void bar() { }",
            "    public F.H third;",
            "  public class D { }",
            "    public F.G fourth;",
            "    int between;",
            "  public class E {",
            "    public void hello() { }",
            "    public void test() { }",
            "  }",
            "}",
            "class F {",
            "  class G { }",
            "  class H { }",
            "}")
        .addExpectedStub(
            "com/example/buck/A$B",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A$B {",
            "",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/A$B com/example/buck/A B",
            "",
            "  // access flags 0x1",
            "  public <init>(Lcom/example/buck/A;)V",
            "}")
        .addExpectedStub(
            "com/example/buck/A$C",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A$C {",
            "",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/A$C com/example/buck/A C",
            "",
            "  // access flags 0x1",
            "  public <init>(Lcom/example/buck/A;)V",
            "}")
        .addExpectedStub(
            "com/example/buck/A$D",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A$D {",
            "",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/A$D com/example/buck/A D",
            "",
            "  // access flags 0x1",
            "  public <init>(Lcom/example/buck/A;)V",
            "}")
        .addExpectedStub(
            "com/example/buck/A$E",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A$E {",
            "",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/A$E com/example/buck/A E",
            "",
            "  // access flags 0x1",
            "  public <init>(Lcom/example/buck/A;)V",
            "",
            "  // access flags 0x1",
            "  public hello()V",
            "",
            "  // access flags 0x1",
            "  public test()V",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/A$E com/example/buck/A E",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/A$D com/example/buck/A D",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/A$C com/example/buck/A C",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/A$B com/example/buck/A B",
            "  // access flags 0x0",
            "  INNERCLASS com/example/buck/F$G com/example/buck/F G",
            "  // access flags 0x0",
            "  INNERCLASS com/example/buck/F$H com/example/buck/F H",
            "",
            "  // access flags 0x0",
            "  Z first",
            "",
            "  // access flags 0x0",
            "  F second",
            "",
            "  // access flags 0x1",
            "  public Lcom/example/buck/F$H; third",
            "",
            "  // access flags 0x1",
            "  public Lcom/example/buck/F$G; fourth",
            "",
            "  // access flags 0x0",
            "  I between",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "",
            "  // access flags 0x1",
            "  public foo()V",
            "",
            "  // access flags 0x1",
            "  public bar()V",
            "}")
        .addExpectedStub(
            "com/example/buck/F$G",
            "// class version 52.0 (52)",
            "// access flags 0x20",
            "class com/example/buck/F$G {",
            "",
            "  // access flags 0x0",
            "  INNERCLASS com/example/buck/F$G com/example/buck/F G",
            "",
            "  // access flags 0x0",
            "  <init>(Lcom/example/buck/F;)V",
            "}")
        .addExpectedStub(
            "com/example/buck/F$H",
            "// class version 52.0 (52)",
            "// access flags 0x20",
            "class com/example/buck/F$H {",
            "",
            "  // access flags 0x0",
            "  INNERCLASS com/example/buck/F$H com/example/buck/F H",
            "",
            "  // access flags 0x0",
            "  <init>(Lcom/example/buck/F;)V",
            "}")
        .addExpectedStub(
            "com/example/buck/F",
            "// class version 52.0 (52)",
            "// access flags 0x20",
            "class com/example/buck/F {",
            "",
            "  // access flags 0x0",
            "  INNERCLASS com/example/buck/F$H com/example/buck/F H",
            "  // access flags 0x0",
            "  INNERCLASS com/example/buck/F$G com/example/buck/F G",
            "",
            "  // access flags 0x0",
            "  <init>()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void genericInterfaceSignaturesShouldBePreserved() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public interface A<T> {",
            "  T get(String key);",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x601",
            "// signature <T:Ljava/lang/Object;>Ljava/lang/Object;",
            "// declaration: com/example/buck/A<T>",
            "public abstract interface com/example/buck/A {",
            "",
            "",
            "  // access flags 0x401",
            "  // signature (Ljava/lang/String;)TT;",
            "  // declaration: T get(java.lang.String)",
            "  public abstract get(Ljava/lang/String;)Ljava/lang/Object;",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void failsWhenInterfaceWillNotLoad() throws IOException {
    if (testingMode != MODE_SOURCE_BASED_MISSING_DEPS) {
      return;
    }

    tester
        .setSourceFile(
            "Dep2.java", "package com.example.buck.dependency;", "public interface Dep2 { }")
        .createStubJar()
        .addStubJarToClasspath()
        .setSourceFile(
            "Dep.java",
            "package com.example.buck.dependency;",
            "public class Dep implements Dep2 {",
            "  public interface Inner { }",
            "}")
        .compileFullJar()
        // We add Dep to the classpath even for no-deps mode, but its interface Dep2 will be absent.
        // That will cause Dep to fail to load, resulting in Inner not even getting added to the
        // interfaces list by the compiler.
        .addFullJarToClasspathAlways()
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            // This next import triggers a bug in javac whereby the inability to load the super
            // of Dep gets marked a "recoverable" error, even though it's not
            "import static com.example.buck.otherdep.NonExistent.Member;",
            "import com.example.buck.dependency.Dep;",
            "public abstract class A implements Dep.Inner, Runnable { }")
        .addExpectedCompileError(
            "A.java:4: error: cannot access com.example.buck.dependency.Dep2\n"
                + "public abstract class A implements Dep.Inner, Runnable { }\n"
                + "                ^\n"
                + "  class file for com.example.buck.dependency.Dep2 not found")
        .createStubJar();
  }

  @Test
  public void failsWhenClassWillNotLoad() throws IOException {
    if (testingMode != MODE_SOURCE_BASED_MISSING_DEPS) {
      return;
    }

    tester
        .setSourceFile(
            "Dep2.java", "package com.example.buck.dependency;", "public interface Dep2 { }")
        .createStubJar()
        .addStubJarToClasspath()
        .setSourceFile(
            "Dep.java",
            "package com.example.buck.dependency;",
            "public class Dep implements Dep2 {",
            "  public static class Inner { }",
            "}")
        .compileFullJar()
        // We add Dep to the classpath even for no-deps mode, but its interface Dep2 will be absent.
        // That will cause Dep to fail to load, resulting in Inner not even getting added to the
        // interfaces list by the compiler.
        .addFullJarToClasspathAlways()
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            // This next import triggers a bug in javac whereby the inability to load the super
            // of Dep gets marked a "recoverable" error, even though it's not
            "import static com.example.buck.otherdep.NonExistent.Member;",
            "import com.example.buck.dependency.Dep;",
            "public class A extends Dep.Inner { }")
        .addExpectedCompileError(
            "A.java:4: error: cannot access com.example.buck.dependency.Dep2\n"
                + "public class A extends Dep.Inner { }\n"
                + "       ^\n"
                + "  class file for com.example.buck.dependency.Dep2 not found")
        .createStubJar();
  }

  /**
   * Regression test for a bug where our error suppressing listener wasn't tracking Context changes
   * across rounds.
   */
  @Test
  public void suppressesErrorsEvenWithMultipleRounds() throws IOException {
    tester
        .setSourceFile("Dep.java", "package com.example.buck.dep;", "public class Dep { }")
        .compileFullJar()
        .addFullJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "import com.example.buck.dep.Dep;",
            "public class A extends Dep {",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A extends com/example/buck/dep/Dep  {",
            "",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        // Having an AP issue a warning causes the listener to warm up during the first roun, thus
        // exposing the bug
        .setIssueAnnotationProcessorWarnings(true)
        .createAndCheckStubJar();
  }

  @Test
  public void shouldPreserveAnnotationsEvenWhenSuperclassWillNotLoad() throws IOException {
    tester
        .setSourceFile(
            "Dep2.java", "package com.example.buck.dependency;", "public interface Dep2 { }")
        .createStubJar()
        .addStubJarToClasspath()
        .setSourceFile(
            "Dep.java",
            "package com.example.buck.dependency;",
            "public class Dep implements Dep2 {",
            "  public static class Inner { }",
            "  public @interface Anno { }",
            "}")
        .compileFullJar()
        // We add Dep to the classpath even for no-deps mode, but its interface Dep2 will be absent.
        // That will cause Dep to fail to load, resulting in Inner not even getting added to the
        // interfaces list by the compiler.
        .addFullJarToClasspathAlways()
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "import com.example.buck.dependency.Dep;",
            "@Dep.Anno",
            "public class A { }")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "",
            "  @Lcom/example/buck/dependency/Dep$Anno;() // invisible",
            "  // access flags 0x2609",
            "  public static abstract INNERCLASS com/example/buck/dependency/Dep$Anno com/example/buck/dependency/Dep Anno",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void shouldIgnorePrivateMethods() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  private void privateMethod() {}",
            "  void packageMethod() {}",
            "  protected void protectedMethod() {}",
            "  public void publicMethod() {}",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "",
            "  // access flags 0x0",
            "  packageMethod()V",
            "",
            "  // access flags 0x4",
            "  protected protectedMethod()V",
            "",
            "  // access flags 0x1",
            "  public publicMethod()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void shouldGenerateConstructorForClassWithSinglePrivateConstructor() throws IOException {
    tester
        .setSourceFile(
            "A.java", "package com.example.buck;", "public class A {", "  private A() { }", "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "",
            "  // access flags 0x2",
            "  private <init>()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void shouldGenerateConstructorForClassWithPrivateConstructorsOnly() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  private A() { }",
            "  private A(int test) { }",
            "  private A(String test) { }",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "",
            "  // access flags 0x2",
            "  private <init>()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void shouldGeneratePrivateInnerClassDefaultConstructor() throws IOException {
    tester
        .setSourceFile(
            "Outer.java",
            "package com.example.buck;",
            "public class Outer {",
            "  public class Inner {",
            "    private Inner() { }",
            "  }",
            "}")
        .addExpectedStub(
            "com/example/buck/Outer$Inner",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/Outer$Inner {",
            "",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/Outer$Inner com/example/buck/Outer Inner",
            "",
            "  // access flags 0x2",
            "  private <init>(Lcom/example/buck/Outer;)V",
            "}")
        .addExpectedStub(
            "com/example/buck/Outer",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/Outer {",
            "",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/Outer$Inner com/example/buck/Outer Inner",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void shouldGeneratePrivateNestedClassDefaultConstructor() throws IOException {
    tester
        .setSourceFile(
            "Outer.java",
            "package com.example.buck;",
            "public class Outer {",
            "  public class Inner {",
            "    public class Nested {",
            "      private Nested() { }",
            "    }",
            "  }",
            "}")
        .addExpectedStub(
            "com/example/buck/Outer$Inner$Nested",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/Outer$Inner$Nested {",
            "",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/Outer$Inner com/example/buck/Outer Inner",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/Outer$Inner$Nested com/example/buck/Outer$Inner Nested",
            "",
            "  // access flags 0x2",
            "  private <init>(Lcom/example/buck/Outer$Inner;)V",
            "}")
        .addExpectedStub(
            "com/example/buck/Outer$Inner",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/Outer$Inner {",
            "",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/Outer$Inner com/example/buck/Outer Inner",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/Outer$Inner$Nested com/example/buck/Outer$Inner Nested",
            "",
            "  // access flags 0x1",
            "  public <init>(Lcom/example/buck/Outer;)V",
            "}")
        .addExpectedStub(
            "com/example/buck/Outer",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/Outer {",
            "",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/Outer$Inner com/example/buck/Outer Inner",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void shouldPreserveAField() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  protected String protectedField;",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "",
            "  // access flags 0x4",
            "  protected Ljava/lang/String; protectedField",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void shouldIgnorePrivateFields() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  private String privateField;",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void shouldPreserveGenericTypesOnFields() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A<T> {",
            "  public T theField;",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "// signature <T:Ljava/lang/Object;>Ljava/lang/Object;",
            "// declaration: com/example/buck/A<T>",
            "public class com/example/buck/A {",
            "",
            "",
            "  // access flags 0x1",
            "  // signature TT;",
            "  // declaration: T",
            "  public Ljava/lang/Object; theField",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void shouldPreserveGenericTypesOnMethods() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A<T> {",
            "  public T get(String key) { return null; }",
            "  public <X extends Comparable<T>> X compareWith(T other) { return null; }",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "// signature <T:Ljava/lang/Object;>Ljava/lang/Object;",
            "// declaration: com/example/buck/A<T>",
            "public class com/example/buck/A {",
            "",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "",
            "  // access flags 0x1",
            "  // signature (Ljava/lang/String;)TT;",
            "  // declaration: T get(java.lang.String)",
            "  public get(Ljava/lang/String;)Ljava/lang/Object;",
            "",
            "  // access flags 0x1",
            "  // signature <X::Ljava/lang/Comparable<TT;>;>(TT;)TX;",
            "  // declaration: X compareWith<X extends java.lang.Comparable<T>>(T)",
            "  public compareWith(Ljava/lang/Object;)Ljava/lang/Comparable;",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void providesNiceErrorWhenAnnotationMissing() throws IOException {
    if (testingMode != MODE_SOURCE_BASED_MISSING_DEPS) {
      return;
    }

    createAnnotationFullJar()
        .addFullJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  @Foo",
            "  public void cheese(String key) {}",
            "}")
        .addExpectedCompileError(
            "A.java:3: error: Could not load the class file for this annotation. Consider adding required_for_source_only_abi = True to its build rule.\n"
                + "  @Foo\n"
                + "  ^")
        .createStubJar();
  }

  @Test
  public void preservesAnnotationsOnMethods() throws IOException {
    notYetImplementedForMissingClasspath();

    createAnnotationFullJar()
        .addFullJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  @Foo",
            "  public void cheese(String key) {}",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "",
            "  // access flags 0x1",
            "  public cheese(Ljava/lang/String;)V",
            "  @Lcom/example/buck/Foo;()",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void preservesAnnotationsOnFields() throws IOException {
    notYetImplementedForMissingClasspath();

    createAnnotationFullJar()
        .addFullJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  @Foo",
            "  public String name;",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "",
            "  // access flags 0x1",
            "  public Ljava/lang/String; name",
            "  @Lcom/example/buck/Foo;()",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void preservesParameterNameMetadata() throws IOException {
    // TODO(jkeljo): We should not be preserving parameter metadata. The parameter metadata is not
    // technically part of the ABI, but the class ABI logic has historically not stripped it out and
    // some projects (Litho) have taken a dependency on it being there.

    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  public void foo(String aString) { }",
            "}")
        .addCompilerOptions("-parameters")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "",
            "  // access flags 0x1",
            "  public foo(Ljava/lang/String;)V",
            "    // parameter  aString",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void preservesAnnotationsOnParameters() throws IOException {
    notYetImplementedForMissingClasspath();

    createAnnotationFullJar()
        .addFullJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  public void peynir(@Foo String very, int tasty) {}",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "",
            "  // access flags 0x1",
            "  public peynir(Ljava/lang/String;I)V",
            "    @Lcom/example/buck/Foo;() // parameter 0",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void preservesTypeAnnotationsInClasses() throws IOException {
    // TODO(jkeljo): It looks like annotated types are not accessible via Elements. The annotated
    // type gets put on the Tree object but doesn't make it to the corresponding Element. We can
    // work around this using Trees.getTypeMirror, but that brings in a lot of classpath challenges
    // that I don't want to deal with right now.
    notYetImplementedForSource();

    createAnnotationFullJar()
        .addFullJarToClasspath()
        .setSourceFile(
            "A.java", "package com.example.buck;", "public class A<@Foo.TypeAnnotation T> { }")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "// signature <T:Ljava/lang/Object;>Ljava/lang/Object;",
            "// declaration: com/example/buck/A<T>",
            "public class com/example/buck/A {",
            "",
            "",
            "  @Lcom/example/buck/Foo$TypeAnnotation;() : CLASS_TYPE_PARAMETER 0, null // invisible",
            "  // access flags 0x2609",
            "  public static abstract INNERCLASS com/example/buck/Foo$TypeAnnotation com/example/buck/Foo TypeAnnotation",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void preservesTypeAnnotationsInMethods() throws IOException {
    // TODO(jkeljo): It looks like annotated types are not accessible via Elements. The annotated
    // type gets put on the Tree object but doesn't make it to the corresponding Element. We can
    // work around this using Trees.getTypeMirror, but that brings in a lot of classpath challenges
    // that I don't want to deal with right now.
    notYetImplementedForSource();

    createAnnotationFullJar()
        .addFullJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  <@Foo.TypeAnnotation T> void foo(@Foo.TypeAnnotation String s) { }",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "  // access flags 0x2609",
            "  public static abstract INNERCLASS com/example/buck/Foo$TypeAnnotation com/example/buck/Foo TypeAnnotation",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "",
            "  // access flags 0x0",
            "  // signature <T:Ljava/lang/Object;>(Ljava/lang/String;)V",
            "  // declaration: void foo<T>(java.lang.String)",
            "  foo(Ljava/lang/String;)V",
            "  @Lcom/example/buck/Foo$TypeAnnotation;() : METHOD_TYPE_PARAMETER 0, null // invisible",
            "  @Lcom/example/buck/Foo$TypeAnnotation;() : METHOD_FORMAL_PARAMETER 0, null // invisible",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void preservesTypeAnnotationsInFields() throws IOException {
    // TODO(jkeljo): It looks like annotated types are not accessible via Elements. The annotated
    // type gets put on the Tree object but doesn't make it to the corresponding Element. We can
    // work around this using Trees.getTypeMirror, but that brings in a lot of classpath challenges
    // that I don't want to deal with right now.
    notYetImplementedForSource();

    createAnnotationFullJar()
        .addFullJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "import java.util.List;",
            "public class A {",
            "  List<@Foo.TypeAnnotation String> list;",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "  // access flags 0x2609",
            "  public static abstract INNERCLASS com/example/buck/Foo$TypeAnnotation com/example/buck/Foo TypeAnnotation",
            "",
            "  // access flags 0x0",
            "  // signature Ljava/util/List<Ljava/lang/String;>;",
            "  // declaration: java.util.List<java.lang.String>",
            "  Ljava/util/List; list",
            "  @Lcom/example/buck/Foo$TypeAnnotation;() : FIELD, 0; // invisible",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void omitsAnnotationsWithSourceRetention() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "import java.lang.annotation.*;",
            "@SourceRetentionAnno()",
            "public class A { }",
            "@Retention(RetentionPolicy.SOURCE)",
            "@interface SourceRetentionAnno { }")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .addExpectedStub(
            "com/example/buck/SourceRetentionAnno",
            "// class version 52.0 (52)",
            "// access flags 0x2600",
            "abstract @interface com/example/buck/SourceRetentionAnno implements java/lang/annotation/Annotation  {",
            "",
            "",
            "  @Ljava/lang/annotation/Retention;(value=Ljava/lang/annotation/RetentionPolicy;.SOURCE)",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void preservesAnnotationsWithClassRetention() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "import java.lang.annotation.*;",
            "@ClassRetentionAnno()",
            "public class A { }",
            "@Retention(RetentionPolicy.CLASS)",
            "@interface ClassRetentionAnno { }")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "",
            "  @Lcom/example/buck/ClassRetentionAnno;() // invisible",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .addExpectedStub(
            "com/example/buck/ClassRetentionAnno",
            "// class version 52.0 (52)",
            "// access flags 0x2600",
            "abstract @interface com/example/buck/ClassRetentionAnno implements java/lang/annotation/Annotation  {",
            "",
            "",
            "  @Ljava/lang/annotation/Retention;(value=Ljava/lang/annotation/RetentionPolicy;.CLASS)",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void preservesAnnotationsWithRuntimeRetention() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "import java.lang.annotation.*;",
            "@RuntimeRetentionAnno()",
            "public class A { }",
            "@Retention(RetentionPolicy.RUNTIME)",
            "@interface RuntimeRetentionAnno { }")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "",
            "  @Lcom/example/buck/RuntimeRetentionAnno;()",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .addExpectedStub(
            "com/example/buck/RuntimeRetentionAnno",
            "// class version 52.0 (52)",
            "// access flags 0x2600",
            "abstract @interface com/example/buck/RuntimeRetentionAnno implements java/lang/annotation/Annotation  {",
            "",
            "",
            "  @Ljava/lang/annotation/Retention;(value=Ljava/lang/annotation/RetentionPolicy;.RUNTIME)",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void preservesAnnotationsWithPrimitiveValues() throws IOException {
    notYetImplementedForMissingClasspath();

    createAnnotationFullJar()
        .addFullJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "@Foo(primitiveValue=1)",
            "public @interface A {}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x2601",
            "public abstract @interface com/example/buck/A implements java/lang/annotation/Annotation  {",
            "",
            "",
            "  @Lcom/example/buck/Foo;(primitiveValue=1)",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void preservesAnnotationsWithStringArrayValues() throws IOException {
    notYetImplementedForMissingClasspath();

    createAnnotationFullJar()
        .addFullJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "@Foo(stringArrayValue={\"1\", \"2\"})",
            "public @interface A {}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x2601",
            "public abstract @interface com/example/buck/A implements java/lang/annotation/Annotation  {",
            "",
            "",
            "  @Lcom/example/buck/Foo;(stringArrayValue={\"1\", \"2\"})",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void preservesAnnotationsWithEnumValues() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "import java.lang.annotation.*;",
            "@Retention(RetentionPolicy.RUNTIME)",
            "public @interface A {}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x2601",
            "public abstract @interface com/example/buck/A implements java/lang/annotation/Annotation  {",
            "",
            "",
            "  @Ljava/lang/annotation/Retention;(value=Ljava/lang/annotation/RetentionPolicy;.RUNTIME)",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void preservesAnnotationsWithTypeValues() throws IOException {
    createAnnotationFullJar()
        .addFullJarToClasspathAlways()
        .setSourceFile(
            "Dependency.java", "package com.example.buck;", "public class Dependency { }")
        .createStubJar()
        .addStubJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "@Foo(typeValue=Dependency.class)",
            "public @interface A {}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x2601",
            "public abstract @interface com/example/buck/A implements java/lang/annotation/Annotation  {",
            "",
            "",
            "  @Lcom/example/buck/Foo;(typeValue=com.example.buck.Dependency.class)",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void preservesAnnotationsWithConstrainedTypeValues() throws IOException {
    createAnnotationFullJar()
        .addFullJarToClasspathAlways()
        .setSourceFile(
            "Dependency.java",
            "package com.example.buck;",
            "public interface Dependency extends Runnable { }")
        .createStubJar()
        .addStubJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "@Foo(runnableValues={Dependency.class})",
            "public @interface A {}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x2601",
            "public abstract @interface com/example/buck/A implements java/lang/annotation/Annotation  {",
            "",
            "",
            "  @Lcom/example/buck/Foo;(runnableValues={com.example.buck.Dependency.class})",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void providesNiceErrorWhenConstantMissing() throws IOException {
    if (testingMode != MODE_SOURCE_BASED_MISSING_DEPS) {
      return;
    }

    createAnnotationFullJar()
        .addFullJarToClasspathAlways()
        .setSourceFile(
            "Dependency.java",
            "package com.example.buck;",
            "public class Dependency { public static final String STRING = \"string\";}")
        .createStubJar()
        .addStubJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "@Foo(stringValue=Dependency.STRING)",
            "public @interface A {}")
        .addExpectedCompileError(
            "A.java:2: error: Could not resolve constant. Either inline the value or add required_for_source_only_abi = True to the build rule that contains it.\n"
                + "@Foo(stringValue=Dependency.STRING)\n"
                + "                           ^")
        .createStubJar();
  }

  @Test
  public void preservesAnnotationsWithConstantValues() throws IOException {
    notYetImplementedForMissingClasspath();

    createAnnotationFullJar()
        .addFullJarToClasspathAlways()
        .setSourceFile(
            "Dependency.java",
            "package com.example.buck;",
            "public class Dependency { public static final String STRING = \"string\";}")
        .createStubJar()
        .addStubJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "@Foo(stringValue=Dependency.STRING)",
            "public @interface A {}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x2601",
            "public abstract @interface com/example/buck/A implements java/lang/annotation/Annotation  {",
            "",
            "",
            "  @Lcom/example/buck/Foo;(stringValue=\"string\")",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void preservesAnnotationsWithEnumArrayValues() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "import java.lang.annotation.*;",
            "@Target({ElementType.CONSTRUCTOR, ElementType.FIELD})",
            "public @interface A {}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x2601",
            "public abstract @interface com/example/buck/A implements java/lang/annotation/Annotation  {",
            "",
            "",
            "  @Ljava/lang/annotation/Target;(value={Ljava/lang/annotation/ElementType;.CONSTRUCTOR, Ljava/lang/annotation/ElementType;.FIELD})",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void preservesAnnotationsWithAnnotationValues() throws IOException {
    notYetImplementedForMissingClasspath();

    createAnnotationFullJar()
        .addFullJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "import java.lang.annotation.*;",
            "@Foo(annotationValue=@Retention(RetentionPolicy.RUNTIME))",
            "public @interface A {}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x2601",
            "public abstract @interface com/example/buck/A implements java/lang/annotation/Annotation  {",
            "",
            "",
            "  @Lcom/example/buck/Foo;(annotationValue=@Ljava/lang/annotation/Retention;(value=Ljava/lang/annotation/RetentionPolicy;.RUNTIME))",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void preservesAnnotationsWithAnnotationArrayValues() throws IOException {
    notYetImplementedForMissingClasspath();

    createAnnotationFullJar()
        .addFullJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "import java.lang.annotation.*;",
            "@Foo(annotationArrayValue=@Retention(RetentionPolicy.RUNTIME))",
            "public @interface A {}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x2601",
            "public abstract @interface com/example/buck/A implements java/lang/annotation/Annotation  {",
            "",
            "",
            "  @Lcom/example/buck/Foo;(annotationArrayValue={@Ljava/lang/annotation/Retention;(value=Ljava/lang/annotation/RetentionPolicy;.RUNTIME)})",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void preservesAnnotationDefaultValues() throws IOException {
    tester
        .setSourceFile(
            "Dependency.java", "package com.example.buck;", "public class Dependency { }")
        .createStubJar()
        .addStubJarToClasspath()
        .setSourceFile(
            "Foo.java",
            "package com.example.buck;",
            "import java.lang.annotation.*;",
            "public @interface Foo {",
            "  int primitiveValue() default 42;",
            "  String[] stringArrayValue() default {\"Hello\", \"World\", \"!\"};",
            "  Retention annotationValue() default @Retention(RetentionPolicy.SOURCE);",
            "  Retention[] annotationArrayValue() default {@Retention(RetentionPolicy.SOURCE), @Retention(RetentionPolicy.CLASS), @Retention(RetentionPolicy.RUNTIME)};",
            "  RetentionPolicy enumValue () default RetentionPolicy.CLASS;",
            "  Class typeValue() default Dependency.class;",
            "}")
        .addExpectedStub(
            "com/example/buck/Foo",
            "// class version 52.0 (52)",
            "// access flags 0x2601",
            "public abstract @interface com/example/buck/Foo implements java/lang/annotation/Annotation  {",
            "",
            "",
            "  // access flags 0x401",
            "  public abstract primitiveValue()I",
            "    default=42",
            "",
            "  // access flags 0x401",
            "  public abstract stringArrayValue()[Ljava/lang/String;",
            "    default={\"Hello\", \"World\", \"!\"}",
            "",
            "  // access flags 0x401",
            "  public abstract annotationValue()Ljava/lang/annotation/Retention;",
            "    default=@Ljava/lang/annotation/Retention;(value=Ljava/lang/annotation/RetentionPolicy;.SOURCE)",
            "",
            "  // access flags 0x401",
            "  public abstract annotationArrayValue()[Ljava/lang/annotation/Retention;",
            "    default={@Ljava/lang/annotation/Retention;(value=Ljava/lang/annotation/RetentionPolicy;.SOURCE), @Ljava/lang/annotation/Retention;(value=Ljava/lang/annotation/RetentionPolicy;.CLASS), @Ljava/lang/annotation/Retention;(value=Ljava/lang/annotation/RetentionPolicy;.RUNTIME)}",
            "",
            "  // access flags 0x401",
            "  public abstract enumValue()Ljava/lang/annotation/RetentionPolicy;",
            "    default=Ljava/lang/annotation/RetentionPolicy;.CLASS",
            "",
            "  // access flags 0x401",
            "  public abstract typeValue()Ljava/lang/Class;",
            "    default=com.example.buck.Dependency.class",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void stubsEnums() throws IOException {
    tester
        .setSourceFile(
            "A.java", "package com.example.buck;", "public enum A {", "  Value1,", "  Value2", "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x4031",
            "// signature Ljava/lang/Enum<Lcom/example/buck/A;>;",
            "// declaration: com/example/buck/A extends java.lang.Enum<com.example.buck.A>",
            "public final enum com/example/buck/A extends java/lang/Enum  {",
            "",
            "",
            "  // access flags 0x4019",
            "  public final static enum Lcom/example/buck/A; Value1",
            "",
            "  // access flags 0x4019",
            "  public final static enum Lcom/example/buck/A; Value2",
            "",
            "  // access flags 0x9",
            "  public static values()[Lcom/example/buck/A;",
            "",
            "  // access flags 0x9",
            "  public static valueOf(Ljava/lang/String;)Lcom/example/buck/A;",
            "",
            "  // access flags 0x2",
            "  private <init>(Ljava/lang/String;I)V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void stubsEnumsOverridingGenericInterface() throws IOException {
    notYetImplementedForMissingClasspath();
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public enum A implements java.util.Comparator<A> {",
            "  Value1,",
            "  Value2;",
            "  @Override",
            "  public int compare(A a1, A a2) { return 0; }",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x4031",
            "// signature Ljava/lang/Enum<Lcom/example/buck/A;>;Ljava/util/Comparator<Lcom/example/buck/A;>;",
            "// declaration: com/example/buck/A extends java.lang.Enum<com.example.buck.A> implements java.util.Comparator<com.example.buck.A>",
            "public final enum com/example/buck/A extends java/lang/Enum  implements java/util/Comparator  {",
            "",
            "",
            "  // access flags 0x4019",
            "  public final static enum Lcom/example/buck/A; Value1",
            "",
            "  // access flags 0x4019",
            "  public final static enum Lcom/example/buck/A; Value2",
            "",
            "  // access flags 0x9",
            "  public static values()[Lcom/example/buck/A;",
            "",
            "  // access flags 0x9",
            "  public static valueOf(Ljava/lang/String;)Lcom/example/buck/A;",
            "",
            "  // access flags 0x1",
            "  public compare(Lcom/example/buck/A;Lcom/example/buck/A;)I",
            "",
            "  // access flags 0x1041",
            "  public synthetic bridge compare(Ljava/lang/Object;Ljava/lang/Object;)I",
            "",
            "  // access flags 0x2",
            "  private <init>(Ljava/lang/String;I)V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void stubsExplicitlyAbstractEnums() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public enum A {",
            "  Value1 {",
            "    @Override",
            "    public void run() { }",
            "  };",
            "  public abstract void run();",
            "}")
        .addExpectedFullAbi(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x4421",
            "// signature Ljava/lang/Enum<Lcom/example/buck/A;>;",
            "// declaration: com/example/buck/A extends java.lang.Enum<com.example.buck.A>",
            // abstract flag is removed in the stub:
            "public abstract enum com/example/buck/A extends java/lang/Enum  {",
            "",
            "  // access flags 0x4008",
            "  static enum INNERCLASS com/example/buck/A$1 null null",
            "",
            "  // access flags 0x4019",
            "  public final static enum Lcom/example/buck/A; Value1",
            "",
            "  // access flags 0x101A",
            "  private final static synthetic [Lcom/example/buck/A; $VALUES",
            "",
            "  // access flags 0x9",
            "  public static values()[Lcom/example/buck/A;",
            "",
            "  // access flags 0x9",
            "  public static valueOf(Ljava/lang/String;)Lcom/example/buck/A;",
            "",
            "  // access flags 0x2",
            "  // signature ()V",
            "  // declaration: void <init>()",
            "  private <init>(Ljava/lang/String;I)V",
            "",
            "  // access flags 0x401",
            "  public abstract run()V",
            "",
            "  // access flags 0x1000",
            "  synthetic <init>(Ljava/lang/String;ILcom/example/buck/A$1;)V",
            "",
            "  // access flags 0x8",
            "  static <clinit>()V",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x4421",
            "// signature Ljava/lang/Enum<Lcom/example/buck/A;>;",
            "// declaration: com/example/buck/A extends java.lang.Enum<com.example.buck.A>",
            "public abstract enum com/example/buck/A extends java/lang/Enum  {",
            "",
            "",
            "  // access flags 0x4019",
            "  public final static enum Lcom/example/buck/A; Value1",
            "",
            "  // access flags 0x9",
            "  public static values()[Lcom/example/buck/A;",
            "",
            "  // access flags 0x9",
            "  public static valueOf(Ljava/lang/String;)Lcom/example/buck/A;",
            "",
            "  // access flags 0x401",
            "  public abstract run()V",
            "",
            "  // access flags 0x2",
            "  private <init>(Ljava/lang/String;I)V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void stubsImplicitlyAbstractEnums() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public enum A implements Runnable {",
            "  Value1 {",
            "    @Override",
            "    public void run() { }",
            "  };",
            "}")
        .addExpectedFullAbi(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x4421",
            "// signature Ljava/lang/Enum<Lcom/example/buck/A;>;Ljava/lang/Runnable;",
            "// declaration: com/example/buck/A extends java.lang.Enum<com.example.buck.A> implements java.lang.Runnable",
            // abstract flag is removed in the stub:
            "public abstract enum com/example/buck/A extends java/lang/Enum  implements java/lang/Runnable  {",
            "",
            "  // access flags 0x4008",
            "  static enum INNERCLASS com/example/buck/A$1 null null",
            "",
            "  // access flags 0x4019",
            "  public final static enum Lcom/example/buck/A; Value1",
            "",
            "  // access flags 0x101A",
            "  private final static synthetic [Lcom/example/buck/A; $VALUES",
            "",
            "  // access flags 0x9",
            "  public static values()[Lcom/example/buck/A;",
            "",
            "  // access flags 0x9",
            "  public static valueOf(Ljava/lang/String;)Lcom/example/buck/A;",
            "",
            "  // access flags 0x2",
            "  // signature ()V",
            "  // declaration: void <init>()",
            "  private <init>(Ljava/lang/String;I)V",
            "",
            "  // access flags 0x1000",
            "  synthetic <init>(Ljava/lang/String;ILcom/example/buck/A$1;)V",
            "",
            "  // access flags 0x8",
            "  static <clinit>()V",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x4421",
            "// signature Ljava/lang/Enum<Lcom/example/buck/A;>;Ljava/lang/Runnable;",
            "// declaration: com/example/buck/A extends java.lang.Enum<com.example.buck.A> implements java.lang.Runnable",
            "public abstract enum com/example/buck/A extends java/lang/Enum  implements java/lang/Runnable  {",
            "",
            "",
            "  // access flags 0x4019",
            "  public final static enum Lcom/example/buck/A; Value1",
            "",
            "  // access flags 0x9",
            "  public static values()[Lcom/example/buck/A;",
            "",
            "  // access flags 0x9",
            "  public static valueOf(Ljava/lang/String;)Lcom/example/buck/A;",
            "",
            "  // access flags 0x2",
            "  private <init>(Ljava/lang/String;I)V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void stubsInnerClasses() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  public class B {",
            "    public int count;",
            "    public void foo() {}",
            "  }",
            "}")
        .addExpectedStub(
            "com/example/buck/A$B",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A$B {",
            "",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/A$B com/example/buck/A B",
            "",
            "  // access flags 0x1",
            "  public I count",
            "",
            "  // access flags 0x1",
            "  public <init>(Lcom/example/buck/A;)V",
            "",
            "  // access flags 0x1",
            "  public foo()V",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/A$B com/example/buck/A B",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void stubsProtectedInnerClasses() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  protected class B {",
            "    public int count;",
            "    public void foo() {}",
            "  }",
            "}")
        .addExpectedStub(
            "com/example/buck/A$B",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A$B {",
            "",
            "  // access flags 0x4",
            "  protected INNERCLASS com/example/buck/A$B com/example/buck/A B",
            "",
            "  // access flags 0x1",
            "  public I count",
            "",
            "  // access flags 0x4",
            "  protected <init>(Lcom/example/buck/A;)V",
            "",
            "  // access flags 0x1",
            "  public foo()V",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "  // access flags 0x4",
            "  protected INNERCLASS com/example/buck/A$B com/example/buck/A B",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void stubsDefaultInnerClasses() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  class B {",
            "    public int count;",
            "    public void foo() {}",
            "  }",
            "}")
        .addExpectedStub(
            "com/example/buck/A$B",
            "// class version 52.0 (52)",
            "// access flags 0x20",
            "class com/example/buck/A$B {",
            "",
            "  // access flags 0x0",
            "  INNERCLASS com/example/buck/A$B com/example/buck/A B",
            "",
            "  // access flags 0x1",
            "  public I count",
            "",
            "  // access flags 0x0",
            "  <init>(Lcom/example/buck/A;)V",
            "",
            "  // access flags 0x1",
            "  public foo()V",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "  // access flags 0x0",
            "  INNERCLASS com/example/buck/A$B com/example/buck/A B",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .createAndCheckStubJar();
  }

  // TODO(jkeljo): We should only be stubbing private inner classes when they are referenced in
  // the ABI. That's a more involved change which I'll make soon, but for now I want to document
  // the existing behavior and ensure it is consistent across class and source-based ABIs.
  @Test
  public void stubsPrivateInnerClasses() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  private class B {",
            "    public int count;",
            "    public void foo() {}",
            "  }",
            "}")
        .addExpectedStub(
            "com/example/buck/A$B",
            "// class version 52.0 (52)",
            "// access flags 0x20",
            "class com/example/buck/A$B {",
            "",
            "  // access flags 0x2",
            "  private INNERCLASS com/example/buck/A$B com/example/buck/A B",
            "",
            "  // access flags 0x1",
            "  public I count",
            "",
            "  // access flags 0x1",
            "  public foo()V",
            "",
            "  // access flags 0x2",
            "  private <init>(Lcom/example/buck/A;)V",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "  // access flags 0x2",
            "  private INNERCLASS com/example/buck/A$B com/example/buck/A B",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void stubsInnerEnums() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  public enum B { Value }",
            "}")
        .addExpectedStub(
            "com/example/buck/A$B",
            "// class version 52.0 (52)",
            "// access flags 0x4031",
            "// signature Ljava/lang/Enum<Lcom/example/buck/A$B;>;",
            "// declaration: com/example/buck/A$B extends java.lang.Enum<com.example.buck.A$B>",
            "public final enum com/example/buck/A$B extends java/lang/Enum  {",
            "",
            "  // access flags 0x4019",
            "  public final static enum INNERCLASS com/example/buck/A$B com/example/buck/A B",
            "",
            "  // access flags 0x4019",
            "  public final static enum Lcom/example/buck/A$B; Value",
            "",
            "  // access flags 0x9",
            "  public static values()[Lcom/example/buck/A$B;",
            "",
            "  // access flags 0x9",
            "  public static valueOf(Ljava/lang/String;)Lcom/example/buck/A$B;",
            "",
            "  // access flags 0x2",
            "  private <init>(Ljava/lang/String;I)V",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "  // access flags 0x4019",
            "  public final static enum INNERCLASS com/example/buck/A$B com/example/buck/A B",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void stubsAbstractInnerEnums() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  public enum B implements Runnable {",
            "    Value {",
            "      @Override",
            "      public void run() {}",
            "    }",
            "  }",
            "}")
        .addExpectedFullAbi(
            "com/example/buck/A$B",
            "// class version 52.0 (52)",
            "// access flags 0x4421",
            "// signature Ljava/lang/Enum<Lcom/example/buck/A$B;>;Ljava/lang/Runnable;",
            "// declaration: com/example/buck/A$B extends java.lang.Enum<com.example.buck.A$B> implements java.lang.Runnable",
            "public abstract enum com/example/buck/A$B extends java/lang/Enum  implements java/lang/Runnable  {",
            "",
            "  // access flags 0x4409",
            "  public static abstract enum INNERCLASS com/example/buck/A$B com/example/buck/A B",
            "  // access flags 0x4008",
            "  static enum INNERCLASS com/example/buck/A$B$1 null null",
            "  // access flags 0x1008",
            "  static synthetic INNERCLASS com/example/buck/A$1 null null",
            "",
            "  // access flags 0x4019",
            "  public final static enum Lcom/example/buck/A$B; Value",
            "",
            "  // access flags 0x101A",
            "  private final static synthetic [Lcom/example/buck/A$B; $VALUES",
            "",
            "  // access flags 0x9",
            "  public static values()[Lcom/example/buck/A$B;",
            "",
            "  // access flags 0x9",
            "  public static valueOf(Ljava/lang/String;)Lcom/example/buck/A$B;",
            "",
            "  // access flags 0x2",
            "  // signature ()V",
            "  // declaration: void <init>()",
            "  private <init>(Ljava/lang/String;I)V",
            "",
            "  // access flags 0x1000",
            "  synthetic <init>(Ljava/lang/String;ILcom/example/buck/A$1;)V",
            "",
            "  // access flags 0x8",
            "  static <clinit>()V",
            "}")
        .addExpectedStub(
            "com/example/buck/A$B",
            "// class version 52.0 (52)",
            "// access flags 0x4421",
            "// signature Ljava/lang/Enum<Lcom/example/buck/A$B;>;Ljava/lang/Runnable;",
            "// declaration: com/example/buck/A$B extends java.lang.Enum<com.example.buck.A$B> implements java.lang.Runnable",
            "public abstract enum com/example/buck/A$B extends java/lang/Enum  implements java/lang/Runnable  {",
            "",
            "  // access flags 0x4409",
            "  public static abstract enum INNERCLASS com/example/buck/A$B com/example/buck/A B",
            "",
            "  // access flags 0x4019",
            "  public final static enum Lcom/example/buck/A$B; Value",
            "",
            "  // access flags 0x9",
            "  public static values()[Lcom/example/buck/A$B;",
            "",
            "  // access flags 0x9",
            "  public static valueOf(Ljava/lang/String;)Lcom/example/buck/A$B;",
            "",
            "  // access flags 0x2",
            "  private <init>(Ljava/lang/String;I)V",
            "}")
        .addExpectedFullAbi(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "  // access flags 0x1008",
            "  static synthetic INNERCLASS com/example/buck/A$1 null null",
            "  // access flags 0x4409",
            "  public static abstract enum INNERCLASS com/example/buck/A$B com/example/buck/A B",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "  // access flags 0x4409",
            "  public static abstract enum INNERCLASS com/example/buck/A$B com/example/buck/A B",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void stubsNestedInnerClasses() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  public class B {",
            "    public class C {",
            "      public int count;",
            "      public void foo() {}",
            "      public class D { }",
            "    }",
            "  }",
            "}")
        .addExpectedFullAbi(
            "com/example/buck/A$B$C$D",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A$B$C$D {",
            "",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/A$B com/example/buck/A B",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/A$B$C com/example/buck/A$B C",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/A$B$C$D com/example/buck/A$B$C D",
            "",
            "  // access flags 0x1010",
            "  final synthetic Lcom/example/buck/A$B$C; this$2",
            "",
            "  // access flags 0x1",
            "  public <init>(Lcom/example/buck/A$B$C;)V",
            "}")
        .addExpectedStub(
            "com/example/buck/A$B$C$D",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A$B$C$D {",
            "",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/A$B com/example/buck/A B",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/A$B$C com/example/buck/A$B C",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/A$B$C$D com/example/buck/A$B$C D",
            "",
            "  // access flags 0x1",
            "  public <init>(Lcom/example/buck/A$B$C;)V",
            "}")
        .addExpectedFullAbi(
            "com/example/buck/A$B$C",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A$B$C {",
            "",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/A$B com/example/buck/A B",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/A$B$C com/example/buck/A$B C",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/A$B$C$D com/example/buck/A$B$C D",
            "",
            "  // access flags 0x1",
            "  public I count",
            "",
            "  // access flags 0x1010",
            "  final synthetic Lcom/example/buck/A$B; this$1",
            "",
            "  // access flags 0x1",
            "  public <init>(Lcom/example/buck/A$B;)V",
            "",
            "  // access flags 0x1",
            "  public foo()V",
            "}")
        .addExpectedStub(
            "com/example/buck/A$B$C",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A$B$C {",
            "",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/A$B com/example/buck/A B",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/A$B$C com/example/buck/A$B C",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/A$B$C$D com/example/buck/A$B$C D",
            "",
            "  // access flags 0x1",
            "  public I count",
            "",
            "  // access flags 0x1",
            "  public <init>(Lcom/example/buck/A$B;)V",
            "",
            "  // access flags 0x1",
            "  public foo()V",
            "}")
        .addExpectedFullAbi(
            "com/example/buck/A$B",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A$B {",
            "",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/A$B com/example/buck/A B",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/A$B$C com/example/buck/A$B C",
            "",
            "  // access flags 0x1010",
            "  final synthetic Lcom/example/buck/A; this$0",
            "",
            "  // access flags 0x1",
            "  public <init>(Lcom/example/buck/A;)V",
            "}")
        .addExpectedStub(
            "com/example/buck/A$B",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A$B {",
            "",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/A$B com/example/buck/A B",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/A$B$C com/example/buck/A$B C",
            "",
            "  // access flags 0x1",
            "  public <init>(Lcom/example/buck/A;)V",
            "}")
        .addExpectedFullAbi(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/A$B com/example/buck/A B",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/A$B com/example/buck/A B",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void stubsReferencesToInnerClassesOfOtherTypes() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  class Inner {",
            "    B.C.D field1;",
            "  }",
            "}",
            "class B {",
            "  public class C {",
            "    public class D { }",
            "  }",
            "}")
        .addExpectedFullAbi(
            "com/example/buck/A$Inner",
            "// class version 52.0 (52)",
            "// access flags 0x20",
            "class com/example/buck/A$Inner {",
            "",
            // An innerclass entry is present for B$C and B$C$D even though they're not inner
            // classes
            // of A, so that the compiler and runtime know how to interpret the name B$C or B$C$D.
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/B$C com/example/buck/B C",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/B$C$D com/example/buck/B$C D",
            "  // access flags 0x0",
            "  INNERCLASS com/example/buck/A$Inner com/example/buck/A Inner",
            "",
            "  // access flags 0x0",
            "  Lcom/example/buck/B$C$D; field1",
            "",
            "  // access flags 0x1010",
            "  final synthetic Lcom/example/buck/A; this$0",
            "",
            "  // access flags 0x0",
            "  <init>(Lcom/example/buck/A;)V",
            "}")
        .addExpectedStub(
            "com/example/buck/A$Inner",
            "// class version 52.0 (52)",
            "// access flags 0x20",
            "class com/example/buck/A$Inner {",
            "",
            "  // access flags 0x0",
            "  INNERCLASS com/example/buck/A$Inner com/example/buck/A Inner",
            // Inenrclass entries for references to other classes are sorted. Otherwise the order
            // in class-based ABIs could be influenced by references inside method bodies.
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/B$C com/example/buck/B C",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/B$C$D com/example/buck/B$C D",
            "",
            "  // access flags 0x0",
            "  Lcom/example/buck/B$C$D; field1",
            "",
            "  // access flags 0x0",
            "  <init>(Lcom/example/buck/A;)V",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "  // access flags 0x0",
            "  INNERCLASS com/example/buck/A$Inner com/example/buck/A Inner",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .addExpectedStub(
            "com/example/buck/B$C$D",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/B$C$D {",
            "",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/B$C com/example/buck/B C",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/B$C$D com/example/buck/B$C D",
            "",
            "  // access flags 0x1",
            "  public <init>(Lcom/example/buck/B$C;)V",
            "}")
        .addExpectedStub(
            "com/example/buck/B$C",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/B$C {",
            "",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/B$C com/example/buck/B C",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/B$C$D com/example/buck/B$C D",
            "",
            "  // access flags 0x1",
            "  public <init>(Lcom/example/buck/B;)V",
            "}")
        .addExpectedStub(
            "com/example/buck/B",
            "// class version 52.0 (52)",
            "// access flags 0x20",
            "class com/example/buck/B {",
            "",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/B$C com/example/buck/B C",
            "",
            "  // access flags 0x0",
            "  <init>()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void stubsReferencesToStaticInnerClassesOfOtherTypes() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  class Inner {",
            "    B.C.D field1;",
            "  }",
            "}",
            "class B {",
            "  public static class C {",
            "    public static class D { }",
            "  }",
            "}")
        .addExpectedFullAbi(
            "com/example/buck/A$Inner",
            "// class version 52.0 (52)",
            "// access flags 0x20",
            "class com/example/buck/A$Inner {",
            "",
            // An innerclass entry is present for B$C and B$C$D even though they're not inner
            // classes
            // of A, so that the compiler and runtime know how to interpret the name B$C or B$C$D.
            "  // access flags 0x9",
            "  public static INNERCLASS com/example/buck/B$C com/example/buck/B C",
            "  // access flags 0x9",
            "  public static INNERCLASS com/example/buck/B$C$D com/example/buck/B$C D",
            "  // access flags 0x0",
            "  INNERCLASS com/example/buck/A$Inner com/example/buck/A Inner",
            "",
            "  // access flags 0x0",
            "  Lcom/example/buck/B$C$D; field1",
            "",
            "  // access flags 0x1010",
            "  final synthetic Lcom/example/buck/A; this$0",
            "",
            "  // access flags 0x0",
            "  <init>(Lcom/example/buck/A;)V",
            "}")
        .addExpectedStub(
            "com/example/buck/A$Inner",
            "// class version 52.0 (52)",
            "// access flags 0x20",
            "class com/example/buck/A$Inner {",
            "",
            "  // access flags 0x0",
            "  INNERCLASS com/example/buck/A$Inner com/example/buck/A Inner",
            // Inenrclass entries for references to other classes are sorted. Otherwise the order
            // in class-based ABIs could be influenced by references inside method bodies.
            "  // access flags 0x9",
            "  public static INNERCLASS com/example/buck/B$C com/example/buck/B C",
            "  // access flags 0x9",
            "  public static INNERCLASS com/example/buck/B$C$D com/example/buck/B$C D",
            "",
            "  // access flags 0x0",
            "  Lcom/example/buck/B$C$D; field1",
            "",
            "  // access flags 0x0",
            "  <init>(Lcom/example/buck/A;)V",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "  // access flags 0x0",
            "  INNERCLASS com/example/buck/A$Inner com/example/buck/A Inner",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .addExpectedStub(
            "com/example/buck/B$C$D",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/B$C$D {",
            "",
            "  // access flags 0x9",
            "  public static INNERCLASS com/example/buck/B$C com/example/buck/B C",
            "  // access flags 0x9",
            "  public static INNERCLASS com/example/buck/B$C$D com/example/buck/B$C D",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .addExpectedStub(
            "com/example/buck/B$C",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/B$C {",
            "",
            "  // access flags 0x9",
            "  public static INNERCLASS com/example/buck/B$C com/example/buck/B C",
            "  // access flags 0x9",
            "  public static INNERCLASS com/example/buck/B$C$D com/example/buck/B$C D",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .addExpectedStub(
            "com/example/buck/B",
            "// class version 52.0 (52)",
            "// access flags 0x20",
            "class com/example/buck/B {",
            "",
            "  // access flags 0x9",
            "  public static INNERCLASS com/example/buck/B$C com/example/buck/B C",
            "",
            "  // access flags 0x0",
            "  <init>()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void stubsReferencesToInnerEnumsOfOtherTypes() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  class Inner {",
            "    B.C.D field1;",
            "  }",
            "}",
            "class B {",
            "  public static class C {",
            "    public static enum D { Value }",
            "  }",
            "}")
        .addExpectedFullAbi(
            "com/example/buck/A$Inner",
            "// class version 52.0 (52)",
            "// access flags 0x20",
            "class com/example/buck/A$Inner {",
            "",
            // An innerclass entry is present for B$C and B$C$D even though they're not inner
            // classes
            // of A, so that the compiler and runtime know how to interpret the name B$C or B$C$D.
            "  // access flags 0x9",
            "  public static INNERCLASS com/example/buck/B$C com/example/buck/B C",
            "  // access flags 0x4019",
            "  public final static enum INNERCLASS com/example/buck/B$C$D com/example/buck/B$C D",
            "  // access flags 0x0",
            "  INNERCLASS com/example/buck/A$Inner com/example/buck/A Inner",
            "",
            "  // access flags 0x0",
            "  Lcom/example/buck/B$C$D; field1",
            "",
            "  // access flags 0x1010",
            "  final synthetic Lcom/example/buck/A; this$0",
            "",
            "  // access flags 0x0",
            "  <init>(Lcom/example/buck/A;)V",
            "}")
        .addExpectedStub(
            "com/example/buck/A$Inner",
            "// class version 52.0 (52)",
            "// access flags 0x20",
            "class com/example/buck/A$Inner {",
            "",
            "  // access flags 0x0",
            "  INNERCLASS com/example/buck/A$Inner com/example/buck/A Inner",
            "  // access flags 0x9",
            "  public static INNERCLASS com/example/buck/B$C com/example/buck/B C",
            "  // access flags 0x4019",
            "  public final static enum INNERCLASS com/example/buck/B$C$D com/example/buck/B$C D",
            "",
            "  // access flags 0x0",
            "  Lcom/example/buck/B$C$D; field1",
            "",
            "  // access flags 0x0",
            "  <init>(Lcom/example/buck/A;)V",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "  // access flags 0x0",
            "  INNERCLASS com/example/buck/A$Inner com/example/buck/A Inner",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .addExpectedStub(
            "com/example/buck/B$C$D",
            "// class version 52.0 (52)",
            "// access flags 0x4031",
            "// signature Ljava/lang/Enum<Lcom/example/buck/B$C$D;>;",
            "// declaration: com/example/buck/B$C$D extends java.lang.Enum<com.example.buck.B$C$D>",
            "public final enum com/example/buck/B$C$D extends java/lang/Enum  {",
            "",
            "  // access flags 0x9",
            "  public static INNERCLASS com/example/buck/B$C com/example/buck/B C",
            "  // access flags 0x4019",
            "  public final static enum INNERCLASS com/example/buck/B$C$D com/example/buck/B$C D",
            "",
            "  // access flags 0x4019",
            "  public final static enum Lcom/example/buck/B$C$D; Value",
            "",
            "  // access flags 0x9",
            "  public static values()[Lcom/example/buck/B$C$D;",
            "",
            "  // access flags 0x9",
            "  public static valueOf(Ljava/lang/String;)Lcom/example/buck/B$C$D;",
            "",
            "  // access flags 0x2",
            "  private <init>(Ljava/lang/String;I)V",
            "}")
        .addExpectedStub(
            "com/example/buck/B$C",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/B$C {",
            "",
            "  // access flags 0x9",
            "  public static INNERCLASS com/example/buck/B$C com/example/buck/B C",
            "  // access flags 0x4019",
            "  public final static enum INNERCLASS com/example/buck/B$C$D com/example/buck/B$C D",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .addExpectedStub(
            "com/example/buck/B",
            "// class version 52.0 (52)",
            "// access flags 0x20",
            "class com/example/buck/B {",
            "",
            "  // access flags 0x9",
            "  public static INNERCLASS com/example/buck/B$C com/example/buck/B C",
            "",
            "  // access flags 0x0",
            "  <init>()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void stubsReferencesToImportedTypesShadowingStarImportedOnes() throws IOException {
    tester
        .setSourceFile("String.java", "package com.example.buck.shadow;", "public class String { }")
        .compileFullJar()
        .addFullJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "import com.example.buck.shadow.String;",
            "public class A {",
            "  String s;",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "",
            "  // access flags 0x0",
            "  Lcom/example/buck/shadow/String; s",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void stubsReferencesToMemberTypesShadowingImportedOnes() throws IOException {
    tester
        .setSourceFile(
            "State.java", "package com.example.buck.state;", "public @interface State { }")
        .compileFullJar()
        .addFullJarToClasspathAlways()
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "import com.example.buck.state.State;",
            "@State",
            "public class A {",
            "  State s;",
            "  public static class State { }",
            "}")
        .addExpectedStub(
            "com/example/buck/A$State",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A$State {",
            "",
            "  // access flags 0x9",
            "  public static INNERCLASS com/example/buck/A$State com/example/buck/A State",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "",
            "  @Lcom/example/buck/state/State;() // invisible",
            "  // access flags 0x9",
            "  public static INNERCLASS com/example/buck/A$State com/example/buck/A State",
            "",
            "  // access flags 0x0",
            "  Lcom/example/buck/A$State; s",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void stubsImportedReferencesToInnerClassesOfOtherTypes() throws IOException {
    notYetImplementedForMissingClasspath();
    tester
        .setSourceFile(
            "Imported.java",
            "package com.example.buck.imported;",
            "public class Imported {",
            "  public class Inner {",
            "    public class Innerer { }",
            "  }",
            "}")
        .compileFullJar()
        .addFullJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "import com.example.buck.imported.Imported.Inner.Innerer;",
            "public class A {",
            "  public Innerer field;",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/imported/Imported$Inner com/example/buck/imported/Imported Inner",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/imported/Imported$Inner$Innerer com/example/buck/imported/Imported$Inner Innerer",
            "",
            "  // access flags 0x1",
            "  public Lcom/example/buck/imported/Imported$Inner$Innerer; field",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void stubsStaticImportedReferencesToInnerClassesOfOtherTypes() throws IOException {
    notYetImplementedForMissingClasspath();

    tester
        .setSourceFile(
            "Imported.java",
            "package com.example.buck.imported;",
            "public class Imported {",
            "  public static class Inner {",
            "    public static class Innerer { }",
            "  }",
            "}")
        .compileFullJar()
        .addFullJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "import static com.example.buck.imported.Imported.Inner.Innerer;",
            "public class A {",
            "  public Innerer field;",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "  // access flags 0x9",
            "  public static INNERCLASS com/example/buck/imported/Imported$Inner com/example/buck/imported/Imported Inner",
            "  // access flags 0x9",
            "  public static INNERCLASS com/example/buck/imported/Imported$Inner$Innerer com/example/buck/imported/Imported$Inner Innerer",
            "",
            "  // access flags 0x1",
            "  public Lcom/example/buck/imported/Imported$Inner$Innerer; field",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void detectsStaticImportedReferencesToMissingInnerClassesOfOtherTypes()
      throws IOException {
    tester
        .setSourceFile(
            "ImportedBase.java",
            "package com.example.buck.imported;",
            "public class ImportedBase {",
            "  public static class Inner {",
            "    public static class Innerer { }",
            "  }",
            "}")
        .compileFullJar()
        .addFullJarToClasspath()
        .setSourceFile(
            "Imported.java",
            "package com.example.buck.imported;",
            "public class Imported extends ImportedBase { }")
        .compileFullJar()
        .addFullJarToClasspathAlways()
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "import static com.example.buck.imported.Imported.Inner;",
            "public class A {",
            "  public Inner field;",
            "}");

    if (testingMode == MODE_SOURCE_BASED_MISSING_DEPS) {
      tester
          .addExpectedCompileError(
              "A.java:2: error: cannot access com.example.buck.imported.ImportedBase\n"
                  + "import static com.example.buck.imported.Imported.Inner;\n"
                  + "^\n"
                  + "  class file for com.example.buck.imported.ImportedBase not found")
          .createStubJar();
    } else {
      tester
          .addExpectedStub(
              "com/example/buck/A",
              "// class version 52.0 (52)",
              "// access flags 0x21",
              "public class com/example/buck/A {",
              "",
              "  // access flags 0x9",
              "  public static INNERCLASS com/example/buck/imported/ImportedBase$Inner com/example/buck/imported/ImportedBase Inner",
              "",
              "  // access flags 0x1",
              "  public Lcom/example/buck/imported/ImportedBase$Inner; field",
              "",
              "  // access flags 0x1",
              "  public <init>()V",
              "}")
          .createAndCheckStubJar();
    }
  }

  @Test
  public void failsOnObviouslyNonExistentStaticImports() throws IOException {
    if (testingMode != MODE_SOURCE_BASED_MISSING_DEPS) {
      return;
    }
    tester
        .setSourceFile(
            "Imported.java", "package com.example.buck.imported;", "public class Imported { }")
        .compileFullJar()
        .addFullJarToClasspathAlways()
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "import static com.example.buck.imported.Imported.Inner;",
            "public class A {",
            "  public Inner field;",
            "}")
        .addExpectedCompileError(
            "A.java:2: error: cannot find symbol\n"
                + "import static com.example.buck.imported.Imported.Inner;\n"
                + "^\n"
                + "  symbol:   static Inner\n"
                + "  location: class")
        .createStubJar();
  }

  @Test
  public void stubsReferencesToInnerClassesOfOtherTypesInAnnotationValues() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "@Anno(B.Inner.class)",
            "public class A {",
            "}",
            "@interface Anno {",
            "  Class<?> value();",
            "}",
            "class B {",
            "  class Inner { }",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "",
            "  @Lcom/example/buck/Anno;(value=com.example.buck.B$Inner.class) // invisible",
            "  // access flags 0x0",
            "  INNERCLASS com/example/buck/B$Inner com/example/buck/B Inner",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .addExpectedStub(
            "com/example/buck/Anno",
            "// class version 52.0 (52)",
            "// access flags 0x2600",
            "abstract @interface com/example/buck/Anno implements java/lang/annotation/Annotation  {",
            "",
            "",
            "  // access flags 0x401",
            "  // signature ()Ljava/lang/Class<*>;",
            "  // declaration: java.lang.Class<?> value()",
            "  public abstract value()Ljava/lang/Class;",
            "}")
        .addExpectedStub(
            "com/example/buck/B$Inner",
            "// class version 52.0 (52)",
            "// access flags 0x20",
            "class com/example/buck/B$Inner {",
            "",
            "  // access flags 0x0",
            "  INNERCLASS com/example/buck/B$Inner com/example/buck/B Inner",
            "",
            "  // access flags 0x0",
            "  <init>(Lcom/example/buck/B;)V",
            "}")
        .addExpectedStub(
            "com/example/buck/B",
            "// class version 52.0 (52)",
            "// access flags 0x20",
            "class com/example/buck/B {",
            "",
            "  // access flags 0x0",
            "  INNERCLASS com/example/buck/B$Inner com/example/buck/B Inner",
            "",
            "  // access flags 0x0",
            "  <init>()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void doesNotStubReferencesToInnerClassesFromInsideMethods() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "import java.util.Map;",
            "public class A {",
            "  public void foo(Map<String, String> map) {",
            "    for (Map.Entry<String, String> entry : map.entrySet()) {",
            "      entry.getValue();",
            "    }",
            "  }",
            "}")
        .addExpectedFullAbi(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "  // access flags 0x609",
            // This entry won't be in the stub:
            "  public static abstract INNERCLASS java/util/Map$Entry java/util/Map Entry",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "",
            "  // access flags 0x1",
            "  // signature (Ljava/util/Map<Ljava/lang/String;Ljava/lang/String;>;)V",
            "  // declaration: void foo(java.util.Map<java.lang.String, java.lang.String>)",
            "  public foo(Ljava/util/Map;)V",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "",
            "  // access flags 0x1",
            "  // signature (Ljava/util/Map<Ljava/lang/String;Ljava/lang/String;>;)V",
            "  // declaration: void foo(java.util.Map<java.lang.String, java.lang.String>)",
            "  public foo(Ljava/util/Map;)V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void stubsReferencesFromBridgeMethodsToInnerClassesOtherTypes() throws IOException {
    notYetImplementedForMissingClasspath();
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  public class B extends C { }",
            "}",
            "class C {",
            "  public D foo() { return new D(); }",
            "  static class D {",
            "  }",
            "}")
        .addExpectedFullAbi(
            "com/example/buck/A$B",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A$B extends com/example/buck/C  {",
            "",
            "  // access flags 0x8",
            "  static INNERCLASS com/example/buck/C$D com/example/buck/C D",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/A$B com/example/buck/A B",
            "",
            "  // access flags 0x1010",
            "  final synthetic Lcom/example/buck/A; this$0",
            "",
            "  // access flags 0x1",
            "  public <init>(Lcom/example/buck/A;)V",
            "",
            "  // access flags 0x1041",
            "  public synthetic bridge foo()Lcom/example/buck/C$D;",
            "}")
        .addExpectedStub(
            "com/example/buck/A$B",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A$B extends com/example/buck/C  {",
            "",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/A$B com/example/buck/A B",
            // TODO: Why is this backwards wrt the full API?
            "  // access flags 0x8",
            "  static INNERCLASS com/example/buck/C$D com/example/buck/C D",
            "",
            "  // access flags 0x1",
            "  public <init>(Lcom/example/buck/A;)V",
            "",
            "  // access flags 0x1041",
            "  public synthetic bridge foo()Lcom/example/buck/C$D;",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/A$B com/example/buck/A B",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .addExpectedStub(
            "com/example/buck/C$D",
            "// class version 52.0 (52)",
            "// access flags 0x20",
            "class com/example/buck/C$D {",
            "",
            "  // access flags 0x8",
            "  static INNERCLASS com/example/buck/C$D com/example/buck/C D",
            "",
            "  // access flags 0x0",
            "  <init>()V",
            "}")
        .addExpectedStub(
            "com/example/buck/C",
            "// class version 52.0 (52)",
            "// access flags 0x20",
            "class com/example/buck/C {",
            "",
            "  // access flags 0x8",
            "  static INNERCLASS com/example/buck/C$D com/example/buck/C D",
            "",
            "  // access flags 0x0",
            "  <init>()V",
            "",
            "  // access flags 0x1",
            "  public foo()Lcom/example/buck/C$D;",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void stubsStaticMemberClasses() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  public static class B {",
            "    public int count;",
            "    public void foo() {}",
            "  }",
            "}")
        .addExpectedStub(
            "com/example/buck/A$B",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A$B {",
            "",
            "  // access flags 0x9",
            "  public static INNERCLASS com/example/buck/A$B com/example/buck/A B",
            "",
            "  // access flags 0x1",
            "  public I count",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "",
            "  // access flags 0x1",
            "  public foo()V",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "  // access flags 0x9",
            "  public static INNERCLASS com/example/buck/A$B com/example/buck/A B",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void ignoresAnonymousClasses() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  public Runnable r = new Runnable() {",
            "    public void run() { }",
            "  };",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "",
            "  // access flags 0x1",
            "  public Ljava/lang/Runnable; r",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void ignoresInnerClassesOfAnonymousClasses() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  public Runnable r = new Runnable() {",
            "    class Inner { }",
            "    public void run() { }",
            "  };",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "",
            "  // access flags 0x1",
            "  public Ljava/lang/Runnable; r",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void ignoresLocalClasses() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  public void method() {",
            "    class Local { };",
            "  }",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "",
            "  // access flags 0x1",
            "  public method()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void preservesAnnotationsOnInnerClassConstructorParameters() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  public class Inner {",
            "    public Inner(@Anno String param) { }",
            "  }",
            "}",
            "@interface Anno {}")
        .addExpectedStub(
            "com/example/buck/A$Inner",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A$Inner {",
            "",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/A$Inner com/example/buck/A Inner",
            "",
            "  // access flags 0x1",
            "  public <init>(Lcom/example/buck/A;Ljava/lang/String;)V",
            "    @Ljava/lang/Synthetic;() // invisible, parameter 0",
            "    @Lcom/example/buck/Anno;() // invisible, parameter 1",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/A$Inner com/example/buck/A Inner",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .addExpectedStub(
            "com/example/buck/Anno",
            "// class version 52.0 (52)",
            "// access flags 0x2600",
            "abstract @interface com/example/buck/Anno implements java/lang/annotation/Annotation  {",
            "",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void preservesThrowsClausesOnInnerClassConstructors() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  public class B {",
            "    B() throws Exception, Throwable {",
            "    }",
            "  }",
            "}")
        .addExpectedStub(
            "com/example/buck/A$B",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A$B {",
            "",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/A$B com/example/buck/A B",
            "",
            "  // access flags 0x0",
            "  <init>(Lcom/example/buck/A;)V throws java/lang/Exception java/lang/Throwable ",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "  // access flags 0x1",
            "  public INNERCLASS com/example/buck/A$B com/example/buck/A B",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void abiSafeChangesResultInTheSameOutputJar() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  protected final static int count = 42;",
            "  public String getGreeting() { return \"hello\"; }",
            "  Class<?> clazz;",
            "  public int other;",
            "}")
        .createStubJar()
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  protected final static int count = 42;",
            "  public String getGreeting() { return \"merhaba\"; }",
            "  Class<?> clazz = String.class;",
            "  public int other = 32;",
            "}")
        .assertStubJarIsIdentical();
  }

  @Test
  public void shouldIncludeInnerClassTypeParameterReferenceInMethodParameter() throws IOException {
    notYetImplementedForMissingClasspath();
    tester
        .setSourceFile(
            "Outer.java",
            "package com.example.buck;",
            "public class Outer {",
            "  public enum Inner { }",
            "}")
        .createStubJar()
        .addStubJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "import java.util.Set;",
            "import com.example.buck.Outer;",
            "public interface A {",
            "  void foo(Set<Outer.Inner> test);",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x601",
            "public abstract interface com/example/buck/A {",
            "",
            "  // access flags 0x4019",
            "  public final static enum INNERCLASS com/example/buck/Outer$Inner com/example/buck/Outer Inner",
            "",
            "  // access flags 0x401",
            "  // signature (Ljava/util/Set<Lcom/example/buck/Outer$Inner;>;)V",
            "  // declaration: void foo(java.util.Set<com.example.buck.Outer$Inner>)",
            "  public abstract foo(Ljava/util/Set;)V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void ordersChangesResultInADifferentOutputJar() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  protected final static int count = 42;",
            "  public String getGreeting() { return \"hello\"; }",
            "  Class<?> clazz;",
            "  public int other;",
            "}")
        .createStubJar()
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  Class<?> clazz;",
            "  public String getGreeting() { return \"hello\"; }",
            "  protected final static int count = 42;",
            "  public int other;",
            "}")
        .assertStubJarIsDifferent();
  }

  @Test
  public void shouldIncludeStaticFields() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  public static String foo;",
            "  public final static int count = 42;",
            "  protected static void method() {}",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "",
            "  // access flags 0x9",
            "  public static Ljava/lang/String; foo",
            "",
            "  // access flags 0x19",
            "  public final static I count = 42",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "",
            "  // access flags 0xC",
            "  protected static method()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void innerClassesInStubsCanBeCompiledAgainst() throws IOException {
    tester
        .setSourceFile(
            "Outer.java",
            "package com.example.buck;",
            "public class Outer {",
            "  public class Inner {",
            "    public String getGreeting() { return \"hola\"; }",
            "  }",
            "}")
        .createStubJar()
        .addStubJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck2;", // Note: different package
            "import com.example.buck.Outer;", // Inner class becomes available
            "public class A {",
            "  private Outer.Inner field;", // Reference the inner class
            "}")
        .testCanCompile();
  }

  @Test
  public void stubsWithNestedClassReferencesCanBeCompiledAgainst() throws IOException {
    tester
        .setSourceFile(
            "Dep.java",
            "package com.example.buck;",
            "public class Dep<T> {",
            "  public static class Nested<U> {",
            "  }",
            "}")
        .createStubJar()
        .addStubJarToClasspath()
        .setSourceFile(
            "UsesDepNested.java",
            "package com.example.buck;",
            "public class UsesDepNested {",
            "  public Dep.Nested<Integer> nested;",
            "}")
        .createStubJar()
        .addStubJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  public UsesDepNested uses;", // Load the inner class reference first
            "  public Dep.Nested<Integer> nested;", // See if it messes up usage
            "}")
        .testCanCompile();
  }

  @Test
  public void stubsWithNestedEnumReferencesCanBeCompiledAgainst() throws IOException {
    tester
        .setSourceFile(
            "Dep.java",
            "package com.example.buck;",
            "public class Dep {",
            "  public static enum Nested {",
            "    One,",
            "    Two",
            "  }",
            "}")
        .createStubJar()
        .addStubJarToClasspath()
        .setSourceFile(
            "UsesDepNested.java",
            "package com.example.buck;",
            "public class UsesDepNested {",
            "  public Dep.Nested nested;",
            "}")
        .createStubJar()
        .addStubJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  public UsesDepNested uses;", // Load the inner class reference first
            "  public Enum nested = Dep.Nested.One;", // See if it messes up usage
            "}")
        .testCanCompile();
  }

  @Test
  public void stubsWithNestedInterfaceReferencesCanBeCompiledAgainst() throws IOException {
    tester
        .setSourceFile(
            "Dep.java",
            "package com.example.buck;",
            "public class Dep<T> {",
            "  public interface Nested<U> {",
            "  }",
            "}")
        .createStubJar()
        .addStubJarToClasspath()
        .setSourceFile(
            "UsesDepNested.java",
            "package com.example.buck;",
            "public class UsesDepNested {",
            "  public Dep.Nested<Integer> nested;",
            "}")
        .createStubJar()
        .addStubJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  public UsesDepNested uses;", // Load the inner class reference first
            "  public Dep.Nested<Integer> nested;", // See if it messes up usage
            "}")
        .testCanCompile();
  }

  @Test
  public void stubsWithNestedInterfaceReferencesDetectIncorrectUsage() throws IOException {
    tester
        .setSourceFile(
            "Dep.java",
            "package com.example.buck;",
            "public class Dep<T> {",
            "  public interface Nested<U> {",
            "  }",
            "}")
        .createStubJar()
        .addStubJarToClasspath()
        .setSourceFile(
            "UsesDepNested.java",
            "package com.example.buck;",
            "public class UsesDepNested {",
            "  public Dep.Nested<Integer> nested;",
            "}")
        .createStubJar()
        .addStubJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  public UsesDepNested uses;", // Load the inner class reference first
            "  public Dep<String>.Nested<Integer> nested;", // See if it messes up usage
            "}")
        .addExpectedCompileError(
            "A.java:4: error: cannot select a static class from a parameterized type\n"
                + "  public Dep<String>.Nested<Integer> nested;\n"
                + "                    ^")
        .testCanCompile();
  }

  @Test
  public void stubsWithInnerClassReferencesCanBeCompiledAgainst() throws IOException {
    tester
        .setSourceFile(
            "Dep.java",
            "package com.example.buck;",
            "public class Dep<T> {",
            "  public class Inner<U> {",
            "    public class Innerer<V> { }",
            "  }",
            "}")
        .createStubJar()
        .addStubJarToClasspath()
        .setSourceFile(
            "UsesDepInner.java",
            "package com.example.buck;",
            "public class UsesDepInner {",
            "  public Dep<String>.Inner<Integer>.Innerer<Long> inner;",
            "}")
        .createStubJar()
        .addStubJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  public UsesDepInner uses;", // Load the inner class reference first
            "  public Dep<String>.Inner<Integer>.Innerer<Long> inner;", // See if it messes up usage
            "}")
        .testCanCompile();
  }

  @Test
  public void stubsWithInnerClassReferencesDetectIncorrectUsage() throws IOException {
    tester
        .setSourceFile(
            "Dep.java",
            "package com.example.buck;",
            "public class Dep<T> {",
            "  public class Inner<U> {",
            "    public class Innerer<V> { }",
            "  }",
            "}")
        .createStubJar()
        .addStubJarToClasspath()
        .setSourceFile(
            "UsesDepInner.java",
            "package com.example.buck;",
            "public class UsesDepInner {",
            "  public Dep<String>.Inner<Integer>.Innerer<Long> inner;",
            "}")
        .createStubJar()
        .addStubJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  public UsesDepInner uses;", // Load the inner class reference first
            "  public Dep<String>.Inner.Innerer<Long> inner;", // See if it messes up usage
            "}")
        .addExpectedCompileError(
            "A.java:4: error: improperly formed type, type arguments given on a raw type\n"
                + "  public Dep<String>.Inner.Innerer<Long> inner;\n"
                + "                                  ^")
        .addExpectedCompileError(
            "A.java:4: error: improperly formed type, some parameters are missing\n"
                + "  public Dep<String>.Inner.Innerer<Long> inner;\n"
                + "                    ^")
        .testCanCompile();
  }

  @Test
  public void staticMethodOfInnerClassInStubsCanBeCompiledAgainst() throws IOException {
    tester
        .setSourceFile(
            "Outer.java",
            "package com.example.buck;",
            "public class Outer {",
            "  public static class Inner {",
            "    public static int testStatic() { return 0; }",
            "  }",
            "}")
        .createStubJar()
        .addStubJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck2;",
            "import com.example.buck.Outer;",
            "public class A {",
            "  public void testMethod() {",
            "    int test = Outer.Inner.testStatic();",
            "  }",
            "}")
        .testCanCompile();
  }

  @Test
  public void privateFieldInInnerClassInStubsCanBeCompiledAgainst() throws IOException {
    tester
        .setSourceFile(
            "Outer.java",
            "package com.example.buck;",
            "public class Outer {",
            "  public String getInnerString() {",
            "    return new Outer.Inner().innerPrivateString;", // Relies on synthetic method
            "  }",
            "  private static final class Inner {",
            "    private final String innerPrivateString = \"hi!\";",
            "  }",
            "}")
        .createStubJar()
        .addStubJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck2;",
            "import com.example.buck.Outer;",
            "public class A {",
            "  public String testMethod() {",
            "    Outer test = new Outer();",
            "    return test.getInnerString();",
            "  }",
            "}")
        .testCanCompile();
  }

  @Test
  public void nestedClassInStubsCanBeCompiledAgainst() throws IOException {
    tester
        .setSourceFile(
            "Outer.java",
            "package com.example.buck;",
            "public class Outer {",
            "  public class Inner {",
            "    public class Nested { }",
            "  }",
            "}")
        .createStubJar()
        .addStubJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck2;",
            "import com.example.buck.Outer;",
            "public class A {",
            "  private Outer.Inner.Nested field;",
            "}")
        .testCanCompile();
  }

  @Test
  public void methodReturningPrivateInnerClassInStubsCanBeCompiledAgainst() throws IOException {
    tester
        .setSourceFile(
            "Test.java",
            "package com.example.buck;",
            "public class Test {",
            "  public static PrivateInner getPrivateInner() {",
            "    return new PrivateInner();",
            "  }",
            "  private static class PrivateInner { }",
            "}")
        .createStubJar()
        .addStubJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck2;",
            "import com.example.buck.Test;",
            "public class A {",
            "  public void test() {",
            "    Object privateInnerObject = Test.getPrivateInner();",
            "  }",
            "}")
        .testCanCompile();
  }

  @Test
  public void methodOfPrivateSuperClassOfInnerPublicClassInStubsCanBeCompiledAgainst()
      throws IOException {
    tester
        .setSourceFile(
            "Test.java",
            "package com.example.buck;",
            "public class Test {",
            "  private class PrivateInner { ",
            "   public void foo() { }",
            "  }",
            "  public class PublicInner extends PrivateInner { }",
            "}")
        .createStubJar()
        .addStubJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck2;",
            "import com.example.buck.Test;",
            "public class A {",
            "  public void test() {",
            "    Test test = new Test();",
            "    Test.PublicInner inner = test.new PublicInner();",
            "    inner.foo();",
            "  }",
            "}")
        .testCanCompile();
  }

  @Test
  public void bridgeMethodInStubsCanBeCompiledAgainst() throws IOException {
    notYetImplementedForMissingClasspath();

    tester
        .setSourceFile(
            "TestGenericInterface.java",
            "package com.example.buck;",
            "public interface TestGenericInterface<T> {",
            "  public int compare(T a, T b);",
            "}")
        .createStubJar()
        .addStubJarToClasspath()
        .setSourceFile(
            "TestComparator.java",
            "package com.example.buck;",
            "import com.example.buck.TestGenericInterface;",
            "public class TestComparator implements TestGenericInterface<Integer> {",
            "  public int compare(Integer a, Integer b) { return 1; }",
            "}")
        .createStubJar()
        .addStubJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck2;",
            "import com.example.buck.TestComparator;",
            "import com.example.buck.TestGenericInterface;",
            "public class A {",
            "  public void test() {",
            "    Object first = 1;",
            "    Object second = 2;",
            "    TestGenericInterface com = new TestComparator();",
            "    int result = com.compare(first, second);", // Relies on bridge method
            "  }",
            "}")
        .testCanCompile();
  }

  @Test
  public void enumInStubsCanBeCompiledAgainst() throws IOException {
    tester
        .setSourceFile(
            "TestEnum.java",
            "package com.example.buck;",
            "public enum TestEnum {",
            "  Value1,",
            "  Value2",
            "}")
        .createStubJar()
        .addStubJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck2;",
            "import com.example.buck.TestEnum;",
            "public class A {",
            "  TestEnum testEnum = TestEnum.Value1;",
            "}")
        .testCanCompile();
  }

  @Test
  public void genericClassInStubsCanBeCompiledAgainst() throws IOException {
    tester
        .setSourceFile(
            "GenericClass.java",
            "package com.example.buck;",
            "public class GenericClass<T> {",
            "  public T theField;",
            "}")
        .createStubJar()
        .addStubJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck2;",
            "import com.example.buck.GenericClass;",
            "public class A {",
            "  public void test() {",
            "    GenericClass<String> field = new GenericClass<>();",
            "    field.theField = \"facebook\";",
            "  }",
            "}")
        .testCanCompile();
  }

  @Test
  public void classExtendingGenericClassInStubsCanBeCompiledAgainst() throws IOException {
    tester
        .setSourceFile(
            "GenericClass.java",
            "package com.example.buck;",
            "public class GenericClass<T> {",
            "  public T theField;",
            "}")
        .createStubJar()
        .addStubJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck2;",
            "import com.example.buck.GenericClass;",
            "public class A<T, M> extends GenericClass<T> {",
            "  public M otherField;",
            "  public A(T t, M m) {",
            "    this.theField = t;",
            "    this.otherField = m;",
            "  }",
            "}")
        .testCanCompile();
  }

  @Test
  public void privateConstructorResultsInCorrectCompileError() throws IOException {
    tester
        .setSourceFile(
            "PrivateTest.java",
            "package com.example.buck;",
            "public class PrivateTest {",
            "  private PrivateTest() { }",
            "}")
        .addExpectedStub(
            "com/example/buck/PrivateTest",
            "// class version 52.0 (52)\n"
                + "// access flags 0x21\n"
                + "public class com/example/buck/PrivateTest {\n"
                + "\n"
                + "\n"
                + "  // access flags 0x2\n"
                + "  private <init>()V\n"
                + "}")
        .createAndCheckStubJar()
        .addStubJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck2;",
            "import com.example.buck.PrivateTest;",
            "public class A {",
            "  public void foo() {",
            "   PrivateTest test = new PrivateTest();",
            "  }",
            "}")
        .addExpectedCompileError(
            Joiner.on('\n')
                .join(
                    "A.java:5: error: PrivateTest() has private access in com.example.buck.PrivateTest",
                    "   PrivateTest test = new PrivateTest();",
                    "                      ^"))
        .testCanCompile();
  }

  @Test
  public void shouldPreserveSynchronizedKeywordOnMethods() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  public synchronized void doMagic() {}",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "",
            "  // access flags 0x21",
            "  public synchronized doMagic()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void shouldKeepMultipleFieldsWithSameDescValue() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  public static final A SEVERE = new A();",
            "  public static final A NOT_SEVERE = new A();",
            "  public static final A QUITE_MILD = new A();",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "",
            "  // access flags 0x19",
            "  public final static Lcom/example/buck/A; SEVERE",
            "",
            "  // access flags 0x19",
            "  public final static Lcom/example/buck/A; NOT_SEVERE",
            "",
            "  // access flags 0x19",
            "  public final static Lcom/example/buck/A; QUITE_MILD",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void shouldNotStubClinit() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  public static int i = 3;",
            "}")
        .addExpectedFullAbi(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "",
            "  // access flags 0x9",
            "  public static I i",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "",
            "  // access flags 0x8",
            "  static <clinit>()V", // Should not stub this, even though it's default access
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "",
            "  // access flags 0x9",
            "  public static I i",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void stubJarIsEquallyAtHomeWalkingADirectoryOfClassFiles()
      throws InterruptedException, IOException {
    Path fullJarPath =
        compileToJar(
            EMPTY_CLASSPATH,
            Collections.emptyList(),
            Collections.emptyList(),
            null,
            "A.java",
            Joiner.on("\n")
                .join(
                    ImmutableList.of(
                        "package com.example.buck;",
                        "public class A {",
                        "  public String toString() { return null; }",
                        "  public void eatCake() {}",
                        "}")),
            temp.newFolder());

    Path classDir = temp.newFolder().toPath();

    ArchiveFormat.ZIP
        .getUnarchiver()
        .extractArchive(
            new DefaultProjectFilesystemFactory(),
            fullJarPath,
            classDir,
            ExistingFileMode.OVERWRITE);

    Path stubJarPath = createStubJar(classDir);
    tester
        .setStubJar(stubJarPath)
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "",
            "  // access flags 0x1",
            "  public toString()Ljava/lang/String;",
            "",
            "  // access flags 0x1",
            "  public eatCake()V",
            "}")
        .checkStubJar();
  }

  @Test
  public void shouldPreserveManifestEntries() throws IOException {
    DeterministicManifest manifest = new DeterministicManifest();
    manifest.getMainAttributes().putValue("Test-Value", "Test");
    manifest.setEntryAttribute("com/example/buck/A.class", "Test-Value", "Test");

    DeterministicManifest expectedManifest = new DeterministicManifest(manifest);
    expectedManifest.setManifestAttribute("Manifest-Version", "1.0");
    expectedManifest.setEntryAttribute(
        "com/example/buck/A.class", "Murmur3-128-Digest", "6ddaf37b8a78b7ae705f31d1512c13c6");

    tester
        .setSourceFile("A.java", "package com.example.buck;", "public class A { }")
        .setManifest(manifest)
        .setExpectedStubManifest(expectedManifest)
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void shouldNotIncludeSyntheticFields() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  public void method() {",
            "    assert false;",
            "  }",
            "}")
        .addExpectedFullAbi(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "",
            "  // access flags 0x1018",
            "  final static synthetic Z $assertionsDisabled", // Should remove this field
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "",
            "  // access flags 0x1",
            "  public method()V",
            "",
            "  // access flags 0x8",
            "  static <clinit>()V",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "",
            "  // access flags 0x1",
            "  public method()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void shouldNotIncludeSyntheticClasses() throws IOException {
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  enum E { Value };",
            "  public void method(E e) {",
            "    switch (e) {",
            "      case Value: break;",
            "    }",
            "  }",
            "}")
        .addExpectedStub(
            "com/example/buck/A$E",
            "// class version 52.0 (52)",
            "// access flags 0x4030",
            "// signature Ljava/lang/Enum<Lcom/example/buck/A$E;>;",
            "// declaration: com/example/buck/A$E extends java.lang.Enum<com.example.buck.A$E>",
            "final enum com/example/buck/A$E extends java/lang/Enum  {",
            "",
            "  // access flags 0x4018",
            "  final static enum INNERCLASS com/example/buck/A$E com/example/buck/A E",
            "",
            "  // access flags 0x4019",
            "  public final static enum Lcom/example/buck/A$E; Value",
            "",
            "  // access flags 0x9",
            "  public static values()[Lcom/example/buck/A$E;",
            "",
            "  // access flags 0x9",
            "  public static valueOf(Ljava/lang/String;)Lcom/example/buck/A$E;",
            "",
            "  // access flags 0x2",
            "  private <init>(Ljava/lang/String;I)V",
            "}")
        .addExpectedFullAbi(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "  // access flags 0x1008",
            "  static synthetic INNERCLASS com/example/buck/A$1 null null",
            // Should not include this class
            "  // access flags 0x4018",
            "  final static enum INNERCLASS com/example/buck/A$E com/example/buck/A E",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "",
            "  // access flags 0x1",
            "  public method(Lcom/example/buck/A$E;)V",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A {",
            "",
            "  // access flags 0x4018",
            "  final static enum INNERCLASS com/example/buck/A$E com/example/buck/A E",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "",
            "  // access flags 0x1",
            "  public method(Lcom/example/buck/A$E;)V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void shouldIncludePackageInfoClassIfAnnotated() throws IOException {
    tester
        .setSourceFile("package-info.java", "@Deprecated", "package com.example.buck;")
        .addExpectedStub(
            "com/example/buck/package-info",
            "// class version 52.0 (52)",
            "// access flags 0x1600",
            "abstract synthetic interface com/example/buck/package-info {",
            "",
            "",
            "  @Ljava/lang/Deprecated;()",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void shouldNotIncludePackageInfoClassIfNotAnnotated() throws IOException {
    tester.setSourceFile("package-info.java", "package com.example.buck;").createAndCheckStubJar();
  }

  @Test
  public void shouldIncludeInnerClassReferencesInPackageInfoClass() throws IOException {
    notYetImplementedForMissingClasspath();
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A {",
            "  public @interface Anno { }",
            "}")
        .createStubJar()
        .addStubJarToClasspath()
        .setSourceFile("package-info.java", "@A.Anno", "package com.example.buck;")
        .addExpectedStub(
            "com/example/buck/package-info",
            "// class version 52.0 (52)",
            "// access flags 0x1600",
            "abstract synthetic interface com/example/buck/package-info {",
            "",
            "",
            "  @Lcom/example/buck/A$Anno;() // invisible",
            "  // access flags 0x2609",
            "  public static abstract INNERCLASS com/example/buck/A$Anno com/example/buck/A Anno",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void shouldNotIncludeSyntheticMethods() throws IOException {
    tester
        .setSourceFile(
            "A.java", "package com.example.buck;", "public enum A {", "  Value1 { }", "}")
        .addExpectedFullAbi(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x4021",
            "// signature Ljava/lang/Enum<Lcom/example/buck/A;>;",
            "// declaration: com/example/buck/A extends java.lang.Enum<com.example.buck.A>",
            "public enum com/example/buck/A extends java/lang/Enum  {",
            "",
            "  // access flags 0x4008",
            "  static enum INNERCLASS com/example/buck/A$1 null null",
            "",
            "  // access flags 0x4019",
            "  public final static enum Lcom/example/buck/A; Value1",
            "",
            "  // access flags 0x101A",
            "  private final static synthetic [Lcom/example/buck/A; $VALUES",
            "",
            "  // access flags 0x9",
            "  public static values()[Lcom/example/buck/A;",
            "",
            "  // access flags 0x9",
            "  public static valueOf(Ljava/lang/String;)Lcom/example/buck/A;",
            "",
            "  // access flags 0x2",
            "  // signature ()V",
            "  // declaration: void <init>()",
            "  private <init>(Ljava/lang/String;I)V",
            "",
            "  // access flags 0x1000",
            "  synthetic <init>(Ljava/lang/String;ILcom/example/buck/A$1;)V",
            // Should not include this method
            "",
            "  // access flags 0x8",
            "  static <clinit>()V",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x4021",
            "// signature Ljava/lang/Enum<Lcom/example/buck/A;>;",
            "// declaration: com/example/buck/A extends java.lang.Enum<com.example.buck.A>",
            "public enum com/example/buck/A extends java/lang/Enum  {",
            "",
            "",
            "  // access flags 0x4019",
            "  public final static enum Lcom/example/buck/A; Value1",
            "",
            "  // access flags 0x9",
            "  public static values()[Lcom/example/buck/A;",
            "",
            "  // access flags 0x9",
            "  public static valueOf(Ljava/lang/String;)Lcom/example/buck/A;",
            "",
            "  // access flags 0x2",
            "  private <init>(Ljava/lang/String;I)V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void shouldIncludeGenericBridgeMethods() throws IOException {
    notYetImplementedForMissingClasspath();
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A implements Comparable<A> {",
            "  public int compareTo(A other) {",
            "    return 0;",
            "  }",
            "}")
        .addExpectedFullAbi(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "// signature Ljava/lang/Object;Ljava/lang/Comparable<Lcom/example/buck/A;>;",
            "// declaration: com/example/buck/A implements java.lang.Comparable<com.example.buck.A>",
            "public class com/example/buck/A implements java/lang/Comparable  {",
            "",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "",
            "  // access flags 0x1",
            "  public compareTo(Lcom/example/buck/A;)I",
            "",
            "  // access flags 0x1041",
            "  public synthetic bridge compareTo(Ljava/lang/Object;)I",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "// signature Ljava/lang/Object;Ljava/lang/Comparable<Lcom/example/buck/A;>;",
            "// declaration: com/example/buck/A implements java.lang.Comparable<com.example.buck.A>",
            "public class com/example/buck/A implements java/lang/Comparable  {",
            "",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "",
            "  // access flags 0x1",
            "  public compareTo(Lcom/example/buck/A;)I",
            "",
            "  // access flags 0x1041",
            "  public synthetic bridge compareTo(Ljava/lang/Object;)I",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void shouldIncludeGenericOverrideBridgeMethods() throws IOException {
    notYetImplementedForMissingClasspath();
    tester
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A extends Super<String> {",
            "  @Override",
            "  public int compareTo(String s) {",
            "    return 0;",
            "  }",
            "}",
            "class Super<T extends CharSequence> implements Comparable<T> {",
            "  @Override",
            "  public int compareTo(T t) {",
            "    return 0;",
            "  }",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "// signature Lcom/example/buck/Super<Ljava/lang/String;>;",
            "// declaration: com/example/buck/A extends com.example.buck.Super<java.lang.String>",
            "public class com/example/buck/A extends com/example/buck/Super  {",
            "",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "",
            "  // access flags 0x1",
            "  public compareTo(Ljava/lang/String;)I",
            "",
            "  // access flags 0x1041",
            "  public synthetic bridge compareTo(Ljava/lang/CharSequence;)I",
            "",
            "  // access flags 0x1041",
            "  public synthetic bridge compareTo(Ljava/lang/Object;)I",
            "}")
        .addExpectedStub(
            "com/example/buck/Super",
            "// class version 52.0 (52)",
            "// access flags 0x20",
            "// signature <T::Ljava/lang/CharSequence;>Ljava/lang/Object;Ljava/lang/Comparable<TT;>;",
            "// declaration: com/example/buck/Super<T extends java.lang.CharSequence> implements java.lang.Comparable<T>",
            "class com/example/buck/Super implements java/lang/Comparable  {",
            "",
            "",
            "  // access flags 0x0",
            "  <init>()V",
            "",
            "  // access flags 0x1",
            "  // signature (TT;)I",
            "  // declaration: int compareTo(T)",
            "  public compareTo(Ljava/lang/CharSequence;)I",
            "",
            "  // access flags 0x1041",
            "  public synthetic bridge compareTo(Ljava/lang/Object;)I",
            "}")
        .createAndCheckStubJar();
  }

  public class Foo<T> implements Callable<T> {
    @Override
    public T call() {
      return null;
    }
  }

  @Test
  public void shouldIncludeCovariantReturnBridgeMethods() throws IOException {
    notYetImplementedForMissingClasspath();
    tester
        .setSourceFile(
            "Super.java",
            "package com.example.buck;",
            "public class Super<T, U> {",
            "  protected Super getThis() { return this; }",
            "  public java.util.List<T> getList() { return null; }",
            "}")
        .compileFullJar()
        .addFullJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A extends Super<String, String> {",
            "  protected A getThis() { return this; }",
            "}")
        .addExpectedFullAbi(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "// signature Lcom/example/buck/Super<Ljava/lang/String;Ljava/lang/String;>;",
            "// declaration: com/example/buck/A extends com.example.buck.Super<java.lang.String, java.lang.String>",
            "public class com/example/buck/A extends com/example/buck/Super  {",
            "",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "",
            "  // access flags 0x4",
            "  protected getThis()Lcom/example/buck/A;",
            "",
            "  // access flags 0x1044",
            "  protected synthetic bridge getThis()Lcom/example/buck/Super;",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "// signature Lcom/example/buck/Super<Ljava/lang/String;Ljava/lang/String;>;",
            "// declaration: com/example/buck/A extends com.example.buck.Super<java.lang.String, java.lang.String>",
            "public class com/example/buck/A extends com/example/buck/Super  {",
            "",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "",
            "  // access flags 0x4",
            "  protected getThis()Lcom/example/buck/A;",
            "",
            "  // access flags 0x1044",
            "  protected synthetic bridge getThis()Lcom/example/buck/Super;",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void
      shouldCopyAccessibilityAnnotationsAndParamNamesFromOverriderAndThrowsFromOverriddenToBridgeMethods()
          throws IOException {
    notYetImplementedForMissingClasspath();
    tester
        .setSourceFile("Anno.java", "package com.example.buck;", "public @interface Anno { }")
        .compileFullJar()
        .addFullJarToClasspathAlways()
        .setSourceFile(
            "Super.java",
            "package com.example.buck;",
            "public class Super {",
            "  protected @SuperAnno Super getThis(@SuperAnno int param) throws Exception { return this; }",
            "  protected Super varargsMethod(int... args) { return this; };",
            "}",
            "@interface SuperAnno { }")
        .compileFullJar()
        .addFullJarToClasspath()
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "import java.io.IOException;",
            "public class A extends Super {",
            "  public @Anno A getThis(@Anno final int i) throws IOException { return this; }",
            "  public A varargsMethod(int... args) { return this; };",
            "}")
        .addCompilerOptions("-parameters")
        .addExpectedFullAbi(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A extends com/example/buck/Super  {",
            "",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "",
            "  // access flags 0x1",
            "  public getThis(I)Lcom/example/buck/A; throws java/io/IOException ",
            "    // parameter final  i",
            "  @Lcom/example/buck/Anno;() // invisible",
            "    @Lcom/example/buck/Anno;() // invisible, parameter 0",
            "",
            "  // access flags 0x81",
            "  public varargs varargsMethod([I)Lcom/example/buck/A;",
            "    // parameter  args",
            "",
            "  // access flags 0x1041",
            "  public synthetic bridge varargsMethod([I)Lcom/example/buck/Super;",
            "    // parameter synthetic  args",
            "",
            "  // access flags 0x1041",
            "  public synthetic bridge getThis(I)Lcom/example/buck/Super; throws java/lang/Exception ",
            "    // parameter final synthetic  i",
            "  @Lcom/example/buck/Anno;() // invisible",
            "    @Lcom/example/buck/Anno;() // invisible, parameter 0",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A extends com/example/buck/Super  {",
            "",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "",
            "  // access flags 0x1",
            "  public getThis(I)Lcom/example/buck/A; throws java/io/IOException ",
            "    // parameter final  i",
            "  @Lcom/example/buck/Anno;() // invisible",
            "    @Lcom/example/buck/Anno;() // invisible, parameter 0",
            "",
            "  // access flags 0x81",
            "  public varargs varargsMethod([I)Lcom/example/buck/A;",
            "    // parameter  args",
            "",
            "  // access flags 0x1041",
            "  public synthetic bridge varargsMethod([I)Lcom/example/buck/Super;",
            "    // parameter synthetic  args",
            "",
            "  // access flags 0x1041",
            "  public synthetic bridge getThis(I)Lcom/example/buck/Super; throws java/lang/Exception ",
            "    // parameter final synthetic  i",
            "  @Lcom/example/buck/Anno;() // invisible",
            "    @Lcom/example/buck/Anno;() // invisible, parameter 0",
            "}")
        .createAndCheckStubJar();
  }

  /**
   * There's this fun case in javac where if a public class has a non-public superclass, all public
   * methods on the superclass get bridges in the subclass. Let's make sure
   */
  @Test
  public void shouldIncludeNonPublicBaseClassBridgeMethods() throws IOException {
    notYetImplementedForMissingClasspath();
    tester
        .setSourceFile(
            "B.java",
            "package com.example.buck;",
            "class B {",
            "  public void foo() {}",
            "public void bar() {}",
            "}")
        .compileFullJar()
        .addFullJarToClasspathAlways()
        .setSourceFile(
            "Super.java",
            "package com.example.buck;",
            "abstract class Super extends B {",
            "  @Override",
            "  public void bar() {}",
            "  public void baz() {}",
            "  public abstract void abstractMethod();", // This one won't get bridged
            "  public final void finalMethod() { }", // Nor will this one
            "}")
        .compileFullJar()
        .addFullJarToClasspathAlways()
        .setSourceFile(
            "A.java", "package com.example.buck;", "public abstract class A extends Super {", "}")
        .addExpectedFullAbi(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x421",
            "public abstract class com/example/buck/A extends com/example/buck/Super  {",
            "",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "",
            "  // access flags 0x1041",
            "  public synthetic bridge baz()V",
            "",
            "  // access flags 0x1041",
            "  public synthetic bridge bar()V",
            "",
            "  // access flags 0x1041",
            "  public synthetic bridge foo()V",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x421",
            "public abstract class com/example/buck/A extends com/example/buck/Super  {",
            "",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "",
            "  // access flags 0x1041",
            "  public synthetic bridge baz()V",
            "",
            "  // access flags 0x1041",
            "  public synthetic bridge bar()V",
            "",
            "  // access flags 0x1041",
            "  public synthetic bridge foo()V",
            "}")
        .createAndCheckStubJar();
  }

  @Test
  public void shouldNotIncludeNonPublicBaseClassBridgeMethodsWhenManuallyDone() throws IOException {
    notYetImplementedForMissingClasspath();
    tester
        .setSourceFile(
            "B.java",
            "package com.example.buck;",
            "class B {",
            "  public void foo() {}",
            "  public void bar() {}",
            "}")
        .compileFullJar()
        .addFullJarToClasspathAlways()
        .setSourceFile(
            "Super.java",
            "package com.example.buck;",
            "public class Super extends B {",
            "  public void bar() {}",
            "}")
        .compileFullJar()
        .addFullJarToClasspathAlways()
        .setSourceFile(
            "A.java",
            "package com.example.buck;",
            "public class A extends Super {",
            "  public void foo() {}",
            "}")
        .addExpectedFullAbi(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A extends com/example/buck/Super  {",
            "",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "",
            "  // access flags 0x1",
            "  public foo()V",
            "}")
        .addExpectedStub(
            "com/example/buck/A",
            "// class version 52.0 (52)",
            "// access flags 0x21",
            "public class com/example/buck/A extends com/example/buck/Super  {",
            "",
            "",
            "  // access flags 0x1",
            "  public <init>()V",
            "",
            "  // access flags 0x1",
            "  public foo()V",
            "}")
        .createAndCheckStubJar();
  }

  private Path createStubJar(Path fullJar) throws IOException {
    Path stubJar = fullJar.getParent().resolve("stub.jar");
    new StubJar(fullJar)
        .setCompatibilityMode(AbiGenerationMode.SOURCE)
        .writeTo(filesystem, stubJar);
    return stubJar;
  }

  private Path compileToJar(
      SortedSet<Path> classpath,
      List<Processor> processors,
      List<String> additionalOptions,
      DeterministicManifest manifest,
      String fileName,
      String source,
      File outputDir)
      throws IOException {
    try (TestCompiler compiler = new TestCompiler()) {
      compiler.init();
      compiler.addCompilerOptions(additionalOptions);
      if (manifest != null) {
        compiler.setManifest(manifest);
      }
      compiler.addSourceFileContents(fileName, source);
      compiler.addClasspath(classpath);
      compiler.setProcessors(processors);

      compiler.compile();

      Path jarPath = outputDir.toPath().resolve("output.jar");
      compiler.getClasses().createJar(jarPath, false);
      return jarPath;
    }
  }

  private Tester createAnnotationFullJar() throws IOException {
    return tester
        .setSourceFile(
            "Foo.java",
            "package com.example.buck;",
            "import java.lang.annotation.*;",
            "import static java.lang.annotation.ElementType.*;",
            "@Retention(RetentionPolicy.RUNTIME)",
            "@Target(value={CONSTRUCTOR, FIELD, METHOD, PARAMETER, TYPE})",
            "public @interface Foo {",
            "  int primitiveValue() default 0;",
            "  String stringValue() default \"default\";",
            "  String[] stringArrayValue() default {\"Hello\"};",
            "  Retention annotationValue() default @Retention(RetentionPolicy.SOURCE);",
            "  Retention[] annotationArrayValue() default {};",
            "  RetentionPolicy enumValue () default RetentionPolicy.CLASS;",
            "  Class typeValue() default Foo.class;",
            "  Class<? extends Runnable>[] runnableValues() default {};",
            "  @Target({TYPE_PARAMETER, TYPE_USE})",
            "  @interface TypeAnnotation { }",
            "}")
        .compileFullJar();
  }

  private void notYetImplementedForMissingClasspath() {
    assumeThat(testingMode, Matchers.not(Matchers.equalTo(MODE_SOURCE_BASED_MISSING_DEPS)));
  }

  private void notYetImplementedForSource() {
    assumeThat(testingMode, Matchers.equalTo(MODE_JAR_BASED));
  }

  private final class Tester {
    private final List<String> expectedStubDirectory = new ArrayList<>();
    private final List<String> actualStubDirectory = new ArrayList<>();
    private final List<String> actualFullDirectory = new ArrayList<>();
    private final Map<String, List<String>> expectedFullAbis = new HashMap<>();
    private final Map<String, List<String>> actualFullAbis = new HashMap<>();
    private final Map<String, List<String>> expectedStubs = new HashMap<>();
    private final Map<String, List<String>> actualStubs = new HashMap<>();
    private final List<String> expectedCompileErrors = new ArrayList<>();
    private final List<String> additionalOptions = new ArrayList<>();
    private DeterministicManifest manifest;
    private List<String> expectedStubManifest;
    private List<String> actualStubManifest;
    private String sourceFileName = "";
    private String sourceFileContents = "";
    private ImmutableSortedSet<Path> universalClasspath = EMPTY_CLASSPATH;
    private ImmutableSortedSet<Path> classpath = EMPTY_CLASSPATH;
    private Path stubJarPath;
    private Path fullJarPath;
    private boolean issueAPWarnings;

    public Tester() {
      expectedStubDirectory.add("META-INF/");
    }

    private void resetActuals() {
      actualStubDirectory.clear();
      actualFullDirectory.clear();
      actualFullAbis.clear();
      actualStubs.clear();
      stubJarPath = null;
      fullJarPath = null;
    }

    public Tester setManifest(DeterministicManifest manifest) {
      this.manifest = manifest;
      return this;
    }

    public Tester setExpectedStubManifest(DeterministicManifest manifest) throws IOException {
      try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {
        manifest.write(out);
        try (InputStreamReader reader =
            new InputStreamReader(new ByteArrayInputStream(out.toByteArray()))) {
          expectedStubManifest = CharStreams.readLines(reader);
        }
      }
      return this;
    }

    public Tester setSourceFile(String fileName, String... lines) {
      sourceFileName = fileName;
      sourceFileContents = Joiner.on('\n').join(lines);
      return this;
    }

    public Tester addCompilerOptions(String... options) {
      additionalOptions.addAll(Arrays.asList(options));
      return this;
    }

    public Tester addExpectedFullAbi(String classBinaryName, String... abiLines) {
      String filePath = classBinaryName + ".class";
      expectedFullAbis.put(filePath, Arrays.asList(abiLines));
      return this;
    }

    public Tester addExpectedStub(String classBinaryName, String... stubLines) {
      String filePath = classBinaryName + ".class";
      if (expectedStubDirectory.size() == 1) {
        expectedStubDirectory.add("com/");
        expectedStubDirectory.add("com/example/");
        expectedStubDirectory.add("com/example/buck/");
      }

      expectedStubDirectory.add(filePath);
      expectedStubs.put(filePath, Arrays.asList(stubLines));
      return this;
    }

    public Tester addExpectedCompileError(String compileError) {
      expectedCompileErrors.add(compileError);
      return this;
    }

    public Tester setStubJar(Path stubJarPath) {
      this.stubJarPath = stubJarPath;
      return this;
    }

    public Tester setIssueAnnotationProcessorWarnings(boolean value) {
      this.issueAPWarnings = value;
      return this;
    }

    public Tester createAndCheckStubJar() throws IOException {
      if (!expectedFullAbis.isEmpty()) {
        compileFullJar();
        dumpFullJarAbi();

        for (String entryName : expectedStubDirectory) {
          if (!expectedFullAbis.containsKey(entryName)) {
            // You don't have to put expectations for all full ABIs, only those that you feel really
            // need to be a certain way for the test to be valid.
            continue;
          }
          assertEquals(
              "Full ABI for " + entryName + " is not what was expected.",
              Joiner.on('\n').join(expectedFullAbis.get(entryName)),
              Joiner.on('\n').join(actualFullAbis.get(entryName)));
        }
      }

      createStubJar();
      return checkStubJar();
    }

    public Tester checkStubJar() throws IOException {
      dumpStubJar();

      assertEquals("File list is not correct.", expectedStubDirectory, actualStubDirectory);

      for (String entryName : expectedStubDirectory) {
        if (entryName.endsWith("/")) {
          continue;
        }
        assertEquals(
            "Stub for " + entryName + " is not correct",
            Joiner.on('\n').join(expectedStubs.get(entryName)),
            Joiner.on('\n').join(actualStubs.get(entryName)));
      }

      if (expectedStubManifest != null) {
        assertEquals(
            Joiner.on('\n').join(expectedStubManifest), Joiner.on('\n').join(actualStubManifest));
      }

      return this;
    }

    public Tester createStubJar() throws IOException {
      File outputDir = temp.newFolder();
      if (testingMode != MODE_JAR_BASED) {
        SortedSet<Path> classpath1 =
            testingMode == MODE_SOURCE_BASED
                ? ImmutableSortedSet.<Path>naturalOrder()
                    .addAll(universalClasspath)
                    .addAll(classpath)
                    .build()
                : universalClasspath;
        Path stubJar = outputDir.toPath().resolve("stub.jar");
        JarBuilder jarBuilder = new JarBuilder();

        try (TestCompiler testCompiler = new TestCompiler()) {
          testCompiler.init();
          testCompiler.addCompilerOptions(additionalOptions);
          if (manifest != null) {
            testCompiler.setManifest(manifest);
          }
          if (testingMode == MODE_SOURCE_BASED_MISSING_DEPS) {
            testCompiler.useFrontendOnlyJavacTask();
          }
          testCompiler.addSourceFileContents(sourceFileName, sourceFileContents);
          testCompiler.addClasspath(classpath1);
          testCompiler.setProcessors(
              Collections.singletonList(
                  new AbstractProcessor() {
                    @Override
                    public Set<String> getSupportedAnnotationTypes() {
                      return Collections.singleton("*");
                    }

                    @Override
                    public SourceVersion getSupportedSourceVersion() {
                      return SourceVersion.RELEASE_8;
                    }

                    @Override
                    public Set<String> getSupportedOptions() {
                      return Collections.emptySet();
                    }

                    @Override
                    public boolean process(
                        Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
                      if (issueAPWarnings) {
                        processingEnv.getMessager().printMessage(Kind.WARNING, "Warning");
                      }
                      return false;
                    }
                  }));
          StubGenerator generator =
              new StubGenerator(
                  SourceVersion.RELEASE_8,
                  testCompiler.getElements(),
                  testCompiler.getTypes(),
                  testCompiler.getMessager(),
                  jarBuilder,
                  new JavacEventSinkToBuckEventBusBridge(
                      new DefaultBuckEventBus(FakeClock.doNotCare(), new BuildId())),
                  AbiGenerationMode.CLASS,
                  additionalOptions.contains("-parameters"));

          testCompiler.addPostEnterCallback(generator::generate);
          testCompiler.setAllowCompilationErrors(!expectedCompileErrors.isEmpty());
          testCompiler.enter();

          if (expectedCompileErrors.isEmpty()) {
            testCompiler.getClasses().writeToJar(jarBuilder);
            jarBuilder.createJarFile(stubJar);
          } else {
            List<String> actualCompileErrors =
                testCompiler
                    .getErrorMessages()
                    .stream()
                    .map(
                        diagnostic ->
                            diagnostic.substring(diagnostic.lastIndexOf(File.separatorChar) + 1))
                    .collect(Collectors.toList());

            assertEquals(expectedCompileErrors, actualCompileErrors);
          }
        }
        stubJarPath = stubJar;
      } else {
        compileFullJar();
        stubJarPath = StubJarTest.this.createStubJar(fullJarPath);
      }

      return this;
    }

    public Tester compileFullJar() throws IOException {
      File outputDir = temp.newFolder();
      fullJarPath =
          compileToJar(
              ImmutableSortedSet.<Path>naturalOrder()
                  .addAll(classpath)
                  .addAll(universalClasspath)
                  .build(),
              Collections.emptyList(),
              additionalOptions,
              manifest,
              sourceFileName,
              sourceFileContents,
              outputDir);
      return this;
    }

    public Tester addStubJarToClasspath() {
      classpath =
          ImmutableSortedSet.<Path>naturalOrder().addAll(classpath).add(stubJarPath).build();
      resetActuals();
      return this;
    }

    public Tester addFullJarToClasspath() {
      classpath =
          ImmutableSortedSet.<Path>naturalOrder().addAll(classpath).add(fullJarPath).build();
      resetActuals();
      return this;
    }

    public Tester addFullJarToClasspathAlways() {
      universalClasspath =
          ImmutableSortedSet.<Path>naturalOrder()
              .addAll(universalClasspath)
              .add(fullJarPath)
              .build();
      resetActuals();
      return this;
    }

    public void testCanCompile() throws IOException {
      File outputDir = temp.newFolder();
      try (TestCompiler compiler = new TestCompiler()) {
        compiler.init();
        compiler.addCompilerOptions(additionalOptions);
        compiler.addSourceFileContents(sourceFileName, sourceFileContents);
        compiler.addClasspath(universalClasspath);
        compiler.addClasspath(classpath);
        compiler.setProcessors(Collections.emptyList());
        compiler.setAllowCompilationErrors(!expectedCompileErrors.isEmpty());

        compiler.compile();
        if (!expectedCompileErrors.isEmpty()) {
          List<String> actualCompileErrors =
              compiler
                  .getErrorMessages()
                  .stream()
                  .map(
                      diagnostic ->
                          diagnostic.substring(diagnostic.lastIndexOf(File.separatorChar) + 1))
                  .collect(Collectors.toList());

          assertEquals(expectedCompileErrors, actualCompileErrors);
        }

        fullJarPath = outputDir.toPath().resolve("output.jar");
        compiler.getClasses().createJar(fullJarPath, false);
      }
    }

    public void assertStubJarIsIdentical() throws IOException {
      Sha1HashCode originalHash = filesystem.computeSha1(stubJarPath);

      createStubJar();

      assertEquals(originalHash, filesystem.computeSha1(stubJarPath));
    }

    public void assertStubJarIsDifferent() throws IOException {
      Sha1HashCode originalHash = filesystem.computeSha1(stubJarPath);

      createStubJar();

      assertNotEquals(originalHash, filesystem.computeSha1(stubJarPath));
    }

    @SuppressWarnings("unused")
    public Tester dumpTestCode(boolean includeFullAbi) throws IOException {
      if (includeFullAbi) {
        compileFullJar();
        dumpFullJarAbi();
      }
      createStubJar();
      dumpStubJar();

      String indent = "            ";
      StringBuilder result = new StringBuilder();
      result.append("Test lines:\n");
      result.append("    tester\n");
      result.append("        .setSourceFile(\n");
      result.append(indent);
      result.append('"');
      result.append(sourceFileName);
      for (String sourceLine : sourceFileContents.split("\n")) {
        result.append("\",\n");
        result.append(indent);
        result.append('"');
        result.append(sourceLine.replace("\"", "\\\""));
      }
      result.append("\")\n");
      for (String fileName : actualFullDirectory) {
        if (fileName.endsWith("/") || fileName.equals(JarFile.MANIFEST_NAME)) {
          continue;
        }
        if (includeFullAbi) {
          result.append("        .addExpectedFullAbi(\n");
          result.append(indent);
          result.append('"');
          result.append(fileName, 0, fileName.length() - ".class".length());

          for (String abiLine : actualFullAbis.get(fileName)) {
            result.append("\",\n");
            result.append(indent);
            result.append('"');
            result.append(abiLine.replace("\"", "\\\""));
          }
          result.append("\")\n");
        }

        if (actualStubs.containsKey(fileName)) {
          result.append("        .addExpectedStub(\n");
          result.append(indent);
          result.append('"');
          result.append(fileName, 0, fileName.length() - ".class".length());

          for (String stubLine : actualStubs.get(fileName)) {
            result.append("\",\n");
            result.append(indent);
            result.append('"');
            result.append(stubLine.replace("\"", "\\\""));
          }
          result.append("\")\n");
        }
      }
      result.append("        .createAndCheckStubJar();\n");

      fail(result.toString());
      return this;
    }

    protected void dumpStubJar() throws IOException {
      try (JarFile file = new JarFile(stubJarPath.toFile())) {
        Iterable<JarEntry> entries = file.stream()::iterator;
        for (JarEntry entry : entries) {
          String name = entry.getName();
          if (JarFile.MANIFEST_NAME.equals(name)) {
            actualStubManifest =
                new JarDumper().dumpEntry(file, entry).collect(Collectors.toList());
            continue;
          }
          actualStubDirectory.add(name);
          actualStubs.put(
              name, new JarDumper().dumpEntry(file, entry).collect(Collectors.toList()));
        }
      }
    }

    protected void dumpFullJarAbi() throws IOException {
      try (JarFile file = new JarFile(fullJarPath.toFile())) {
        Iterable<JarEntry> entries = file.stream()::iterator;
        for (JarEntry entry : entries) {
          String name = entry.getName();
          if (JarFile.MANIFEST_NAME.equals(name)) {
            continue;
          }
          actualFullDirectory.add(name);
          actualFullAbis.put(
              name,
              new JarDumper()
                  .setAsmFlags(
                      ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES)
                  .dumpEntry(file, entry)
                  .collect(Collectors.toList()));
        }
      }
    }
  }
}

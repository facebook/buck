/*
 * Copyright 2014-present Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

package com.facebook.buck.jvm.java.abi;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeThat;

import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.jvm.java.testutil.CompilerTreeApiParameterized;
import com.facebook.buck.jvm.java.testutil.TestCompiler;
import com.facebook.buck.util.sha1.Sha1HashCode;
import com.facebook.buck.zip.Unzip;
import com.google.common.base.Joiner;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSortedSet;

import org.hamcrest.Matchers;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.AnnotationNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldNode;
import org.objectweb.asm.tree.InnerClassNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.ParameterNode;
import org.objectweb.asm.tree.TypeAnnotationNode;

import java.io.File;
import java.io.IOException;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.SortedSet;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.stream.Collectors;

import javax.annotation.processing.Processor;
import javax.lang.model.SourceVersion;

@RunWith(CompilerTreeApiParameterized.class)
public class StubJarTest {
  // Test a stub generated by stripping a full jar
  private static final String MODE_JAR_BASED = "JAR_BASED";

  // Test a stub generated from source
  private static final String MODE_SOURCE_BASED = "SOURCE_BASED";

  // Test a stub generated from source, with dependencies missing
  private static final String MODE_SOURCE_BASED_MISSING_DEPS = "SOURCE_BASED_MISSING_DEPS";

  private static final String ANNOTATION_SOURCE = Joiner.on("\n").join(ImmutableList.of(
      "package com.example.buck;",
      "import java.lang.annotation.*;",
      "import static java.lang.annotation.ElementType.*;",
      "@Retention(RetentionPolicy.RUNTIME)",
      "@Target(value={CONSTRUCTOR, FIELD, METHOD, PARAMETER, TYPE})",
      "public @interface Foo {",
      "  int primitiveValue() default 0;",
      "  String[] stringArrayValue() default {\"Hello\"};",
      "  Retention annotationValue() default @Retention(RetentionPolicy.SOURCE);",
      "  Retention[] annotationArrayValue() default {};",
      "  RetentionPolicy enumValue () default RetentionPolicy.CLASS;",
      "  Class typeValue() default Foo.class;",
      "  @Target({TYPE_PARAMETER, TYPE_USE})",
      "  @interface TypeAnnotation { }",
      "}"
  ));

  @Parameterized.Parameter
  public String testingMode;
  private boolean allowCompilationErrors = false;
  private List<String> diagnostics;
  private Set<String> allowedInnerClassNames = new HashSet<>();

  @Parameterized.Parameters
  public static Object[] getParameters() {
    return new Object[]{MODE_JAR_BASED, MODE_SOURCE_BASED, MODE_SOURCE_BASED_MISSING_DEPS};
  }

  private static final ImmutableSortedSet<Path> EMPTY_CLASSPATH = ImmutableSortedSet.of();

  @Rule
  public TemporaryFolder temp = new TemporaryFolder();

  private ProjectFilesystem filesystem;

  @Before
  public void createTempFilesystem() throws IOException {
    File out = temp.newFolder();
    filesystem = new ProjectFilesystem(out.toPath());
  }

  @Test
  public void emptyClass() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        "package com.example.buck; public class A {}");

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");

    // Verify that the stub jar works by compiling some code that depends on A.
    compileToJar(
        ImmutableSortedSet.of(paths.stubJar),
        Collections.emptyList(),
        "B.java",
        "package com.example.buck; public class B extends A {}",
        temp.newFolder());
  }

  @Test
  public void emptyClassWithAnnotation() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        "package com.example.buck; @Deprecated public class A {}");

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");
  }

  @Test
  public void classWithTwoMethods() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on("\n").join(ImmutableList.of(
            "package com.example.buck;",
            "public class A {",
            "  public String toString() { return null; }",
            "  public void eatCake() {}",
            "}")));

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");

  }

  @Test
  public void preservesThrowsClauses() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on('\n').join(
            "package com.example.buck;",
            "public class A {",
            "  public void throwSomeStuff() throws Exception, Throwable {}",
            "}"));

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");
  }

  @Test
  public void preservesThrowsClausesWithTypeVars() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on('\n').join(
            "package com.example.buck;",
            "import java.io.IOException;",
            "public class A {",
            "  public <E extends IOException> void throwSomeStuff() throws E {}",
            "}"));

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");
  }

  @Test
  public void genericClassSignaturesShouldBePreserved() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class A<T> {",
                "  public T get(String key) { return null; }",
                "}"
            )));

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");
  }

  @Test
  public void elementsInStubCorrectlyInOrder() throws IOException {
    // Fields and methods should stub in order
    // Inner classes should stub in reverse
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class A {",
                "    boolean first;",
                "    float second;",
                "  public void foo() { }",
                "  public class B { }",
                "  public class C { }",
                "  public void bar() { }",
                "  public class D { }",
                "    int between;",
                "  public class E {",
                "    public void hello() { }",
                "    public void test() { }",
                "  }",
                "}"
            )));

    assertClassesStubbedCorrectly(
        paths,
        "com/example/buck/A.class",
        "com/example/buck/A$B.class",
        "com/example/buck/A$C.class",
        "com/example/buck/A$D.class",
        "com/example/buck/A$E.class");
  }

  @Test
  public void genericInterfaceSignaturesShouldBePreserved() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public interface A<T> {",
                "  T get(String key);",
                "}"
            )));

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");
  }

  @Test
  public void shouldIgnorePrivateMethods() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class A {",
                "  private void privateMethod() {}",
                "  void packageMethod() {}",
                "  protected void protectedMethod() {}",
                "  public void publicMethod() {}",
                "}"
            )));

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");
  }

  @Test
  public void shouldGenerateConstructorForClassWithSinglePrivateConstructor() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class A {",
                "  private A() { }",
                "}"
            )));

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");
  }

  @Test
  public void shouldGenerateConstructorForClassWithPrivateConstructorsOnly() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class A {",
                "  private A() { }",
                "  private A(int test) { }",
                "  private A(String test) { }",
                "}"
            )));

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");
  }

  @Test
  public void shouldGeneratePrivateInnerClassDefaultConstructor() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "Outer.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class Outer {",
                "  public class Inner {",
                "    private Inner() { }",
                "  }",
                "}"
            )));

    assertClassesStubbedCorrectly(
        paths,
        "com/example/buck/Outer.class",
        "com/example/buck/Outer$Inner.class");
  }

  @Test
  public void shouldGeneratePrivateNestedClassDefaultConstructor() throws IOException {
    notYetImplementedForSource();

    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "Outer.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class Outer {",
                "  public class Inner {",
                "    public class Nested {",
                "      private Nested() { }",
                "    }",
                "  }",
                "}"
            )));

    assertClassesStubbedCorrectly(
        paths,
        "com/example/buck/Outer.class",
        "com/example/buck/Outer$Inner.class",
        "com/example/buck/Outer$Inner$Nested.class");
  }

  @Test
  public void shouldPreserveAField() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class A {",
                "  protected String protectedField;",
                "}"
            )));

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");
  }

  @Test
  public void shouldIgnorePrivateFields() throws IOException {
    notYetImplementedForSource();

    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class A {",
                "  private String privateField;",
                "}"
            )));

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");
  }

  @Test
  public void shouldPreserveGenericTypesOnFields() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class A<T> {",
                "  public T theField;",
                "}")));

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");
  }

  @Test
  public void shouldPreserveGenericTypesOnMethods() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class A<T> {",
                "  public T get(String key) { return null; }",
                "  public <X extends Comparable<T>> X compareWith(T other) { return null; }",
                "}")));

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");
  }

  @Test
  public void preservesAnnotationsOnMethods() throws IOException {
    notYetImplementedForMissingClasspath();

    Path annotations = createAnnotationFullJar();
    JarPaths paths = createFullAndStubJars(
        ImmutableSortedSet.of(annotations),
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class A {",
                "  @Foo",
                "  public void cheese(String key) {}",
                "}")));

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");
  }

  @Test
  public void preservesAnnotationsOnFields() throws IOException {
    notYetImplementedForMissingClasspath();

    Path annotations = createAnnotationFullJar();
    JarPaths paths = createFullAndStubJars(
        ImmutableSortedSet.of(annotations),
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class A {",
                "  @Foo",
                "  public String name;",
                "}")));

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");
  }

  @Test
  public void preservesAnnotationsOnParameters() throws IOException {
    notYetImplementedForMissingClasspath();

    Path annotations = createAnnotationFullJar();
    JarPaths paths = createFullAndStubJars(
        ImmutableSortedSet.of(annotations),
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class A {",
                "  public void peynir(@Foo String very, int tasty) {}",
                "}")));

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");
  }

  @Test
  public void preservesTypeAnnotationsInClasses() throws IOException {
    // TODO(jkeljo): It looks like annotated types are not accessible via Elements. The annotated
    // type gets put on the Tree object but doesn't make it to the corresponding Element. We can
    // work around this using Trees.getTypeMirror, but that brings in a lot of classpath challenges
    // that I don't want to deal with right now.
    notYetImplementedForSource();

    Path annotations = createAnnotationFullJar();

    JarPaths paths = createFullAndStubJars(
        ImmutableSortedSet.of(annotations),
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class A<@Foo.TypeAnnotation T> { }")));

    addAllowedInnerClassNames("com/example/buck/Foo$TypeAnnotation");
    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");
  }

  @Test
  public void preservesTypeAnnotationsInMethods() throws IOException {
    // TODO(jkeljo): It looks like annotated types are not accessible via Elements. The annotated
    // type gets put on the Tree object but doesn't make it to the corresponding Element. We can
    // work around this using Trees.getTypeMirror, but that brings in a lot of classpath challenges
    // that I don't want to deal with right now.
    notYetImplementedForSource();

    Path annotations = createAnnotationFullJar();

    JarPaths paths = createFullAndStubJars(
        ImmutableSortedSet.of(annotations),
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class A {",
                "  <@Foo.TypeAnnotation T> void foo(@Foo.TypeAnnotation String s) { }",
                "}")));

    addAllowedInnerClassNames("com/example/buck/Foo$TypeAnnotation");
    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");
  }

  @Test
  public void preservesTypeAnnotationsInFields() throws IOException {
    // TODO(jkeljo): It looks like annotated types are not accessible via Elements. The annotated
    // type gets put on the Tree object but doesn't make it to the corresponding Element. We can
    // work around this using Trees.getTypeMirror, but that brings in a lot of classpath challenges
    // that I don't want to deal with right now.
    notYetImplementedForSource();

    Path annotations = createAnnotationFullJar();

    JarPaths paths = createFullAndStubJars(
        ImmutableSortedSet.of(annotations),
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "import java.util.List;",
                "public class A {",
                "  List<@Foo.TypeAnnotation String> list;",
                "}")));

    addAllowedInnerClassNames("com/example/buck/Foo$TypeAnnotation");
    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");
  }

  @Test
  public void omitsAnnotationsWithSourceRetention() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on('\n').join(
            "package com.example.buck;",
            "import java.lang.annotation.*;",
            "@SourceRetentionAnno()",
            "public class A { }",
            "@Retention(RetentionPolicy.SOURCE)",
            "@interface SourceRetentionAnno { }"));

    assertClassesStubbedCorrectly(
        paths,
        "com/example/buck/A.class",
        "com/example/buck/SourceRetentionAnno.class");
  }

  @Test
  public void preservesAnnotationsWithClassRetention() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on('\n').join(
            "package com.example.buck;",
            "import java.lang.annotation.*;",
            "@ClassRetentionAnno()",
            "public class A { }",
            "@Retention(RetentionPolicy.CLASS)",
            "@interface ClassRetentionAnno { }"));

    assertClassesStubbedCorrectly(
        paths,
        "com/example/buck/A.class",
        "com/example/buck/ClassRetentionAnno.class");
  }

  @Test
  public void preservesAnnotationsWithRuntimeRetention() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on('\n').join(
            "package com.example.buck;",
            "import java.lang.annotation.*;",
            "@RuntimeRetentionAnno()",
            "public class A { }",
            "@Retention(RetentionPolicy.RUNTIME)",
            "@interface RuntimeRetentionAnno { }"));

    assertClassesStubbedCorrectly(
        paths,
        "com/example/buck/A.class",
        "com/example/buck/RuntimeRetentionAnno.class");
  }

  @Test
  public void preservesAnnotationsWithPrimitiveValues() throws IOException {
    notYetImplementedForMissingClasspath();

    Path annotations = createAnnotationFullJar();
    JarPaths paths = createFullAndStubJars(
        ImmutableSortedSet.of(annotations),
        "A.java",
        Joiner.on("\n").join(
            "package com.example.buck;",
            "@Foo(primitiveValue=1)",
            "public @interface A {}"));

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");
  }

  @Test
  public void preservesAnnotationsWithStringArrayValues() throws IOException {
    notYetImplementedForMissingClasspath();

    Path annotations = createAnnotationFullJar();
    JarPaths paths = createFullAndStubJars(
        ImmutableSortedSet.of(annotations),
        "A.java",
        Joiner.on("\n").join(
            "package com.example.buck;",
            "@Foo(stringArrayValue={\"1\", \"2\"})",
            "public @interface A {}"));

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");
  }

  @Test
  public void preservesAnnotationsWithEnumValues() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on("\n").join(
            "package com.example.buck;",
            "import java.lang.annotation.*;",
            "@Retention(RetentionPolicy.RUNTIME)",
            "public @interface A {}"));

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");
  }

  @Test
  public void preservesAnnotationsWithTypeValues() throws IOException {
    notYetImplementedForMissingClasspath();

    Path annotations = createAnnotationFullJar();
    JarPaths paths = createFullAndStubJars(
        ImmutableSortedSet.of(annotations),
        "A.java",
        Joiner.on("\n").join(
            "package com.example.buck;",
            "@Foo(typeValue=String.class)",
            "public @interface A {}"));

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");
  }

  @Test
  public void preservesAnnotationsWithEnumArrayValues() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on("\n").join(
            "package com.example.buck;",
            "import java.lang.annotation.*;",
            "@Target({ElementType.CONSTRUCTOR, ElementType.FIELD})",
            "public @interface A {}"));

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");
  }

  @Test
  public void preservesAnnotationsWithAnnotationValues() throws IOException {
    notYetImplementedForMissingClasspath();

    Path annotations = createAnnotationFullJar();
    JarPaths paths = createFullAndStubJars(
        ImmutableSortedSet.of(annotations),
        "A.java",
        Joiner.on("\n").join(
            "package com.example.buck;",
            "import java.lang.annotation.*;",
            "@Foo(annotationValue=@Retention(RetentionPolicy.RUNTIME))",
            "public @interface A {}"));

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");
  }

  @Test
  public void preservesAnnotationsWithAnnotationArrayValues() throws IOException {
    notYetImplementedForMissingClasspath();

    Path annotations = createAnnotationFullJar();
    JarPaths paths = createFullAndStubJars(
        ImmutableSortedSet.of(annotations),
        "A.java",
        Joiner.on("\n").join(
            "package com.example.buck;",
            "import java.lang.annotation.*;",
            "@Foo(annotationArrayValue=@Retention(RetentionPolicy.RUNTIME))",
            "public @interface A {}"));

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");
  }

  @Test
  public void preservesAnnotationsWithDefaultValues() throws IOException {
    notYetImplementedForMissingClasspath();

    Path annotations = createAnnotationFullJar();
    JarPaths paths = createFullAndStubJars(
        ImmutableSortedSet.of(annotations),
        "A.java",
        Joiner.on("\n").join(
            "package com.example.buck;",
            "@Foo()",
            "public @interface A {}"));

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");
  }

  @Test
  public void preservesAnnotationPrimitiveDefaultValues() throws IOException {
    JarPaths paths = createAnnotationFullAndStubJars();

    assertClassesStubbedCorrectly(
        paths,
        "com/example/buck/Foo.class",
        "com/example/buck/Foo$TypeAnnotation.class");
  }

  @Test
  public void preservesAnnotationArrayDefaultValues() throws IOException {
    JarPaths paths = createAnnotationFullAndStubJars();

    assertClassesStubbedCorrectly(
        paths,
        "com/example/buck/Foo.class",
        "com/example/buck/Foo$TypeAnnotation.class");
  }

  @Test
  public void preservesAnnotationAnnotationDefaultValues() throws IOException {
    JarPaths paths = createAnnotationFullAndStubJars();

    assertClassesStubbedCorrectly(
        paths,
        "com/example/buck/Foo.class",
        "com/example/buck/Foo$TypeAnnotation.class");
  }

  @Test
  public void preservesAnnotationEnumDefaultValues() throws IOException {
    JarPaths paths = createAnnotationFullAndStubJars();

    assertClassesStubbedCorrectly(
        paths,
        "com/example/buck/Foo.class",
        "com/example/buck/Foo$TypeAnnotation.class");
  }

  @Test
  public void preservesAnnotationTypeDefaultValues() throws IOException {
    JarPaths paths = createAnnotationFullAndStubJars();

    assertClassesStubbedCorrectly(
        paths,
        "com/example/buck/Foo.class",
        "com/example/buck/Foo$TypeAnnotation.class");
  }

  @Test
  public void stubsEnums() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on("\n").join(
            "package com.example.buck;",
            "public enum A {",
            "  Value1,",
            "  Value2",
            "}"
        ));

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");
  }

  @Test
  public void stubsAbstractEnums() throws IOException {
    notYetImplementedForSource();

    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on("\n").join(
            "package com.example.buck;",
            "public enum A {",
            "  Value1 {",
            "    public int get() { return 1; }",
            "  };",
            "  public abstract int get();",
            "}"));

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");
    assertClassesNotStubbed(paths, "com/example/buck/A$1.class");
  }

  @Test
  public void stubsInnerClasses() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class A {",
                "  public class B {",
                "    public int count;",
                "    public void foo() {}",
                "  }",
                "}"
            )));

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class", "com/example/buck/A$B.class");
  }

  @Test
  public void stubsProtectedInnerClasses() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class A {",
                "  protected class B {",
                "    public int count;",
                "    public void foo() {}",
                "  }",
                "}"
            )));

    assertClassesStubbedCorrectly(
        paths,
        "com/example/buck/A.class",
        "com/example/buck/A$B.class");
  }

  @Test
  public void stubsDefaultInnerClasses() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class A {",
                "  class B {",
                "    public int count;",
                "    public void foo() {}",
                "  }",
                "}"
            )));

    assertClassesStubbedCorrectly(
        paths,
        "com/example/buck/A.class",
        "com/example/buck/A$B.class");
  }

  @Test
  public void stubsInnerEnums() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class A {",
                "  public enum B { Value }",
                "}"
            )));

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class", "com/example/buck/A$B.class");
  }

  @Test
  public void stubsNestedInnerClasses() throws IOException {
    notYetImplementedForSource();

    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class A {",
                "  public class B {",
                "    public class C {",
                "      public int count;",
                "      public void foo() {}",
                "    }",
                "  }",
                "}"
            )));

    assertClassesStubbedCorrectly(
        paths,
        "com/example/buck/A.class",
        "com/example/buck/A$B.class",
        "com/example/buck/A$B$C.class");
  }

  @Test
  public void doesNotStubReferencesToInnerClassesOfOtherTypes() throws IOException {
    notYetImplementedForSource();
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class A {",
                "  B.C field;",
                "}",
                "class B {",
                "  public class C { }",
                "}"
            )));

    assertClassesStubbedCorrectly(
        paths,
        "com/example/buck/A.class",
        "com/example/buck/B.class",
        "com/example/buck/B$C.class");
  }

  @Test
  public void stubsStaticMemberClasses() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class A {",
                "  public static class B {",
                "    public int count;",
                "    public void foo() {}",
                "  }",
                "}"
            )));

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class", "com/example/buck/A$B.class");
  }

  @Test
  public void ignoresAnonymousClasses() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class A {",
                "  public Runnable r = new Runnable() {",
                "    public void run() { }",
                "  };",
                "}"
            )));

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");
    assertClassesNotStubbed(paths, "com/example/buck/A$1.class");
  }

  @Test
  public void ignoresLocalClasses() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class A {",
                "  public void method() {",
                "    class Local { };",
                "  }",
                "}"
            )));

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");
    assertClassesNotStubbed(paths, "com/example/buck/A$1Local.class");
  }

  @Test
  public void preservesThrowsClausesOnInnerClassConstructors() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on('\n').join(
            "package com.example.buck;",
            "public class A {",
            "  public class B {",
            "    B() throws Exception, Throwable {",
            "    }",
            "  }",
            "}"
        ));

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class", "com/example/buck/A$B.class");
  }

  @Test
  public void abiSafeChangesResultInTheSameOutputJar() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class A {",
                "  protected final static int count = 42;",
                "  public String getGreeting() { return \"hello\"; }",
                "  Class<?> clazz;",
                "  public int other;",
                "}"
            )));
    Sha1HashCode originalHash = filesystem.computeSha1(paths.stubJar);

    paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class A {",
                "  protected final static int count = 42;",
                "  public String getGreeting() { return \"merhaba\"; }",
                "  Class<?> clazz = String.class;",
                "  public int other = 32;",
                "}"
            )));
    Sha1HashCode secondHash = filesystem.computeSha1(paths.stubJar);

    assertEquals(originalHash, secondHash);
  }

  @Test
  public void shouldIncludeInnerClassTypeParameterReferenceInMethodParameter() throws IOException {
    notYetImplementedForSource();

    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "Outer.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class Outer {",
                "  public enum Inner { }",
                "}"
            )));

    paths = createFullAndStubJars(
        ImmutableSortedSet.of(paths.stubJar),
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "import java.util.Set;",
                "import com.example.buck.Outer;",
                "public interface A {",
                "  void foo(Set<Outer.Inner> test);",
                "}"
            )));

    addAllowedInnerClassNames("com/example/buck/Outer$Inner");
    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");
  }

  @Test
  public void ordersChangesResultInADifferentOutputJar() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class A {",
                "  protected final static int count = 42;",
                "  public String getGreeting() { return \"hello\"; }",
                "  Class<?> clazz;",
                "  public int other;",
                "}"
            )));
    Sha1HashCode originalHash = filesystem.computeSha1(paths.stubJar);

    paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class A {",
                "  Class<?> clazz;",
                "  public String getGreeting() { return \"hello\"; }",
                "  protected final static int count = 42;",
                "  public int other;",
                "}"
            )));
    Sha1HashCode secondHash = filesystem.computeSha1(paths.stubJar);

    assertNotEquals(originalHash, secondHash);
  }

  @Test
  public void shouldIncludeStaticFields() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class A {",
                "  public static String foo;",
                "  public final static int count = 42;",
                "  protected static void method() {}",
                "}")));
    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");
  }

  @Test
  public void innerClassesInStubsCanBeCompiledAgainst() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "Outer.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class Outer {",
                "  public class Inner {",
                "    public String getGreeting() { return \"hola\"; }",
                "  }",
                "}")));

    compileToJar(
        ImmutableSortedSet.of(paths.stubJar),
        Collections.emptyList(),
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck2;",      // Note: different package
                "import com.example.buck.Outer;",  // Inner class becomes available
                "public class A {",
                "  private Outer.Inner field;",    // Reference the inner class
                "}")),
        temp.newFolder());
  }

  @Test
  public void staticMethodOfInnerClassInStubsCanBeCompiledAgainst() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "Outer.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class Outer {",
                "  public static class Inner {",
                "    public static int testStatic() { return 0; }",
                "  }",
                "}")));

    compileToJar(
        ImmutableSortedSet.of(paths.stubJar),
        Collections.emptyList(),
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck2;",
                "import com.example.buck.Outer;",
                "public class A {",
                "  public void testMethod() {",
                "    int test = Outer.Inner.testStatic();",
                "  }",
                "}")),
        temp.newFolder());
  }

  @Test
  public void privateFieldInInnerClassInStubsCanBeCompiledAgainst() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "Outer.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class Outer {",
                "  public String getInnerString() {",
                "    return new Outer.Inner().innerPrivateString;", // Relies on synthetic method
                "  }",
                "  private static final class Inner {",
                "    private final String innerPrivateString = \"hi!\";",
                "  }",
                "}")));

    compileToJar(
        ImmutableSortedSet.of(paths.stubJar),
        Collections.emptyList(),
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck2;",
                "import com.example.buck.Outer;",
                "public class A {",
                "  public String testMethod() {",
                "    Outer test = new Outer();",
                "    return test.getInnerString();",
                "  }",
                "}")),
        temp.newFolder());
  }

  @Test
  public void nestedClassInStubsCanBeCompiledAgainst() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "Outer.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class Outer {",
                "  public class Inner {",
                "    public class Nested { }",
                "  }",
                "}")));

    compileToJar(
        ImmutableSortedSet.of(paths.stubJar),
        Collections.emptyList(),
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck2;",
                "import com.example.buck.Outer;",
                "public class A {",
                "  private Outer.Inner.Nested field;",
                "}")),
        temp.newFolder());
  }

  @Test
  public void methodReturningPrivateInnerClassInStubsCanBeCompiledAgainst() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "Test.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class Test {",
                "  public static PrivateInner getPrivateInner() {",
                "    return new PrivateInner();",
                "  }",
                "  private static class PrivateInner { }",
                "}")));

    compileToJar(
        ImmutableSortedSet.of(paths.stubJar),
        Collections.emptyList(),
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck2;",
                "import com.example.buck.Test;",
                "public class A {",
                "  public void test() {",
                "    Object privateInnerObject = Test.getPrivateInner();",
                "  }",
                "}")),
        temp.newFolder());
  }

  @Test
  public void methodOfPrivateSuperClassOfInnerPublicClassInStubsCanBeCompiledAgainst()
      throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "Test.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class Test {",
                "  private class PrivateInner { ",
                "   public void foo() { }",
                "  }",
                "  public class PublicInner extends PrivateInner { }",
                "}")));

    compileToJar(
        ImmutableSortedSet.of(paths.stubJar),
        Collections.emptyList(),
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck2;",
                "import com.example.buck.Test;",
                "public class A {",
                "  public void test() {",
                "    Test test = new Test();",
                "    Test.PublicInner inner = test.new PublicInner();",
                "    inner.foo();",
                "  }",
                "}")),
        temp.newFolder());
  }

  @Test
  public void bridgeMethodInStubsCanBeCompiledAgainst()
      throws IOException {
    notYetImplementedForMissingClasspath();

    JarPaths genericPaths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "TestGenericInterface.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public interface TestGenericInterface<T> {",
                "  public int compare(T a, T b);",
                "}")));

    JarPaths paths = createFullAndStubJars(
        ImmutableSortedSet.of(genericPaths.stubJar),
        "TestComparator.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "import com.example.buck.TestGenericInterface;",
                "public class TestComparator implements TestGenericInterface<Integer> {",
                "  public int compare(Integer a, Integer b) { return 1; }",
                "}")));

    compileToJar(
        ImmutableSortedSet.of(paths.stubJar, genericPaths.stubJar),
        Collections.emptyList(),
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck2;",
                "import com.example.buck.TestComparator;",
                "import com.example.buck.TestGenericInterface;",
                "public class A {",
                "  public void test() {",
                "    Object first = 1;",
                "    Object second = 2;",
                "    TestGenericInterface com = new TestComparator();",
                "    int result = com.compare(first, second);", // Relies on bridge method
                "  }",
                "}")),
        temp.newFolder());
  }

  @Test
  public void enumInStubsCanBeCompiledAgainst()
      throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "TestEnum.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public enum TestEnum {",
                "  Value1,",
                "  Value2",
                "}")));

    compileToJar(
        ImmutableSortedSet.of(paths.stubJar),
        Collections.emptyList(),
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck2;",
                "import com.example.buck.TestEnum;",
                "public class A {",
                "  TestEnum testEnum = TestEnum.Value1;",
                "}")),
        temp.newFolder());
  }

  @Test
  public void genericClassInStubsCanBeCompiledAgainst()
      throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "GenericClass.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class GenericClass<T> {",
                "  public T theField;",
                "}")));

    compileToJar(
        ImmutableSortedSet.of(paths.stubJar),
        Collections.emptyList(),
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck2;",
                "import com.example.buck.GenericClass;",
                "public class A {",
                "  public void test() {",
                "    GenericClass<String> field = new GenericClass<>();",
                "    field.theField = \"facebook\";",
                "  }",
                "}")),
        temp.newFolder());
  }

  @Test
  public void classExtendingGenericClassInStubsCanBeCompiledAgainst()
      throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "GenericClass.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class GenericClass<T> {",
                "  public T theField;",
                "}")));

    compileToJar(
        ImmutableSortedSet.of(paths.stubJar),
        Collections.emptyList(),
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck2;",
                "import com.example.buck.GenericClass;",
                "public class A<T, M> extends GenericClass<T> {",
                "  public M otherField;",
                "  public A(T t, M m) {",
                "    this.theField = t;",
                "    this.otherField = m;",
                "  }",
                "}")),
        temp.newFolder());
  }

  @Test
  public void privateConstructorResultsInCorrectCompileError() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "PrivateTest.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class PrivateTest {",
                "  private PrivateTest() { }",
                "}")));

    allowCompilationErrors = true;
    compileToJar(
        ImmutableSortedSet.of(paths.stubJar),
        Collections.emptyList(),
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck2;",
                "import com.example.buck.PrivateTest;",
                "public class A {",
                "  public void foo() {",
                "   PrivateTest test = new PrivateTest();",
                "  }",
                "}")),
        temp.newFolder());

    ImmutableList<String> expectedErrors =
        ImmutableList.of(Joiner.on('\n').join(
            "A.java:5: error: PrivateTest() has private access in com.example.buck.PrivateTest",
            "   PrivateTest test = new PrivateTest();",
            "                      ^"));
    assertCompilationErrors(expectedErrors);
  }

  @Test
  public void shouldPreserveSynchronizedKeywordOnMethods() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class A {",
                "  public synchronized void doMagic() {}",
                "}")));

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");
  }

  @Test
  public void shouldKeepMultipleFieldsWithSameDescValue() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class A {",
                "  public static final A SEVERE = new A();",
                "  public static final A NOT_SEVERE = new A();",
                "  public static final A QUITE_MILD = new A();",
                "}")));

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");
  }

  @Test
  public void shouldNotStubClinit() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on('\n').join(
            "package com.example.buck;",
            "public class A {",
            "  public static int i = 3;",
            "}"));

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");
  }

  @Test
  public void stubJarIsEquallyAtHomeWalkingADirectoryOfClassFiles() throws IOException {
    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on("\n").join(
            ImmutableList.of(
                "package com.example.buck;",
                "public class A {",
                "  public String toString() { return null; }",
                "  public void eatCake() {}",
                "}")));

    Path classDir = temp.newFolder().toPath();
    Unzip.extractZipFile(paths.fullJar, classDir, Unzip.ExistingFileMode.OVERWRITE);

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");
  }

  @Test
  public void shouldIncludeBridgeMethods() throws IOException {
    notYetImplementedForSource();

    JarPaths paths = createFullAndStubJars(
        EMPTY_CLASSPATH,
        "A.java",
        Joiner.on('\n').join(ImmutableList.of(
            "package com.example.buck;",
            "public class A implements Comparable<A> {",
            "  public int compareTo(A other) {",
            "    return 0;",
            "  }",
            "}")));

    assertClassesStubbedCorrectly(paths, "com/example/buck/A.class");
  }

  private JarPaths createFullAndStubJars(
      ImmutableSortedSet<Path> classPath,
      String fileName,
      String source) throws IOException {
    File outputDir = temp.newFolder();
    Path fullJar = compileToJar(
        classPath,
        Collections.emptyList(),
        fileName,
        source,
        outputDir);

    Path stubJar;
    if (testingMode != MODE_JAR_BASED) {
      stubJar = createStubJar(
          testingMode == MODE_SOURCE_BASED ? classPath : Collections.emptySortedSet(),
          fileName,
          source,
          outputDir.toPath());
    } else {
      stubJar = createStubJar(fullJar);
    }

    return new JarPaths(fullJar, stubJar);
  }

  private Path createStubJar(
      SortedSet<Path> classpath,
      String fileName,
      String source,
      Path outputDir) throws IOException {
    Path stubJar = outputDir.resolve("stub.jar");

    List<Processor> processors = Collections.singletonList(new StubJarGeneratingProcessor(
        filesystem,
        stubJar,
        SourceVersion.RELEASE_8));

    try (TestCompiler testCompiler = new TestCompiler()) {
      testCompiler.init();
      testCompiler.useFrontendOnlyJavacTask();
      testCompiler.addSourceFileContents(fileName, source);
      testCompiler.addClasspath(classpath);
      testCompiler.setProcessors(processors);
      testCompiler.enter();
    }

    return stubJar;
  }

  private Path createStubJar(Path fullJar) throws IOException {
    Path stubJar = fullJar.getParent().resolve("stub.jar");
    new StubJar(fullJar).writeTo(filesystem, stubJar);
    return stubJar;
  }

  private Path compileToJar(
      SortedSet<Path> classpath,
      List<Processor> processors,
      String fileName,
      String source,
      File outputDir) throws IOException {
    try (TestCompiler compiler = new TestCompiler()) {
      compiler.init();
      compiler.addSourceFileContents(fileName, source);
      compiler.addClasspath(classpath);
      compiler.setProcessors(processors);
      compiler.setAllowCompilationErrors(allowCompilationErrors);

      compiler.compile();
      diagnostics = compiler.getDiagnosticMessages();

      Path jarPath = outputDir.toPath().resolve("output.jar");
      compiler.getClasses().createJar(jarPath);
      return jarPath;
    }
  }

  private AbiClass readClass(Path pathToJar, String className) throws IOException {
    return AbiClass.extract(filesystem.getPathForRelativePath(pathToJar), className);
  }

  private JarPaths createAnnotationFullAndStubJars() throws IOException {
    return createFullAndStubJars(
        EMPTY_CLASSPATH,
        "Foo.java",
        ANNOTATION_SOURCE);
  }

  private Path createAnnotationFullJar() throws IOException {
    return compileToJar(
        EMPTY_CLASSPATH,
        Collections.emptyList(),
        "Foo.java",
        ANNOTATION_SOURCE,
        temp.newFolder());
  }

  private void assertClassesNotStubbed(
      JarPaths paths,
      String... classFilePaths) throws IOException {
    for (String classFilePath : classFilePaths) {
      AbiClass stubbed = readClass(paths.stubJar, classFilePath);
      if (stubbed != null) {
        fail(String.format("Should not have stubbed %s", stubbed.getClassNode().name));
      }
    }
  }

  private void assertClassesStubbedCorrectly(
      JarPaths paths,
      String... classFilePaths) throws IOException {
    for (String classFilePath : classFilePaths) {
      String classFileName =
          classFilePath.substring(classFilePath.lastIndexOf(File.separatorChar) + 1);
      if (classFileName.contains("$")) {
        addAllowedInnerClassNames(classFilePath.substring(0, classFilePath.lastIndexOf('.')));
      }
    }

    for (String classFilePath : classFilePaths) {
      AbiClass original = readClass(paths.fullJar, classFilePath);
      AbiClass stubbed = readClass(paths.stubJar, classFilePath);

      assertClassStubbedCorrectly(original, stubbed);
    }
  }

  /**
   * A class is stubbed correctly if the stub is exactly the same as its full counterpart, with
   * the following exceptions:
   * <ul>
   * <li>No private members, &lt;clinit&gt;, synthetic members, bridge methods, or method bodies
   * are present</li>
   * </ul>
   */
  private void assertClassStubbedCorrectly(AbiClass original, AbiClass stubbed) {
    if (original == null) {
      if (stubbed != null) {
        fail(String.format("Should not have stubbed %s", stubbed.getClassNode().name));
      }
      return;
    }
    assertNotNull(String.format("Should have stubbed %s", original.getClassNode().name), stubbed);

    ClassNode originalNode = original.getClassNode();
    ClassNode stubbedNode = stubbed.getClassNode();

    assertEquals(originalNode.version, stubbedNode.version);
    assertEquals(originalNode.access, stubbedNode.access);
    assertEquals(originalNode.name, stubbedNode.name);
    assertEquals(originalNode.signature, stubbedNode.signature);
    assertEquals(originalNode.superName, stubbedNode.superName);
    assertThat(stubbedNode.interfaces, Matchers.equalTo(originalNode.interfaces));
    assertNull(stubbedNode.sourceFile);
    assertNull(stubbedNode.sourceDebug);
    assertEquals(originalNode.outerClass, stubbedNode.outerClass);
    assertNull(stubbedNode.outerMethod);
    assertNull(stubbedNode.outerMethodDesc);
    assertAnnotationsEqual(originalNode.visibleAnnotations, stubbedNode.visibleAnnotations);
    assertAnnotationsEqual(originalNode.invisibleAnnotations, stubbedNode.invisibleAnnotations);
    assertTypeAnnotationsEqual(
        originalNode.visibleTypeAnnotations,
        stubbedNode.visibleTypeAnnotations);
    assertTypeAnnotationsEqual(
        originalNode.invisibleTypeAnnotations,
        stubbedNode.invisibleTypeAnnotations);
    assertEquals(originalNode.attrs, stubbedNode.attrs);
    assertInnerClassesStubbedCorrectly(
        originalNode.innerClasses,
        stubbedNode.innerClasses);
    assertFieldsStubbedCorrectly(originalNode.fields, stubbedNode.fields);
    assertMethodsStubbedCorrectly(originalNode.methods, stubbedNode.methods);
  }

  private void assertInnerClassesStubbedCorrectly(
      List<InnerClassNode> original,
      List<InnerClassNode> stubbed) {
    List<InnerClassNode> filteredOriginal = original.stream()
        .filter(node -> allowedInnerClassNames.contains(node.name))
        .collect(Collectors.toList());
    assertMembersStubbedCorrectly(
        filteredOriginal,
        stubbed,
        node -> node.access,
        StubJarTest::assertInnerClassStubbedCorrectly);
  }

  private static void assertMethodsStubbedCorrectly(
      List<MethodNode> original,
      List<MethodNode> stubbed) {
    boolean hasConstructor = false;
    List<MethodNode> filteredOriginal = new ArrayList<>();
    for (MethodNode m : original) {
      if (m.name.equals("<clinit>") && m.desc.equals("()V")) {
        continue;
      }
      if (m.name.equals("<init>")) {
        hasConstructor = true;
      }
      filteredOriginal.add(m);
    }

    // Check that our stubbed class has a constructor if it should
    if (hasConstructor) {
      List<MethodNode> stubbedConstructors = stubbed.stream()
          .filter(m -> m.name.equals("<init>") && (m.access & Opcodes.ACC_SYNTHETIC) == 0)
          .collect(Collectors.toList());
      if (stubbedConstructors.size() == 1 &&
          (stubbedConstructors.get(0).access & Opcodes.ACC_PRIVATE) > 0) {
        // A single private default constructor will exist if the stubbed class only has private
        // constructors. We remove it before comparing since we'll filter all private methods from
        // the original class anyway. See AbiFilteringClassVisitor.visitMethod() for more info
        stubbed.remove(stubbedConstructors.get(0));
      } else if (stubbedConstructors.size() == 0) {
        fail("No constructor found.\n" +
            "This stubbed class should at least have a default private constructor!");
      }
    }

    assertMembersStubbedCorrectly(
        filteredOriginal,
        stubbed,
        node -> node.access,
        StubJarTest::assertMethodStubbedCorrectly);
  }

  private static void assertFieldsStubbedCorrectly(
      List<FieldNode> original,
      List<FieldNode> stubbed) {
    assertMembersStubbedCorrectly(
        original,
        stubbed,
        node -> node.access,
        StubJarTest::assertFieldStubbedCorrectly);
  }

  private static <M> void assertMembersStubbedCorrectly(
      List<M> original,
      List<M> stubbed,
      Function<M, Integer> getAccess,
      BiFunction<M, M, Void> assertMemberStubbedCorrectly) {
    List<M> filtered = original.stream()
        .filter(m -> {
          if (m instanceof InnerClassNode) {
            return true;
          }
          // Never stub things that are private
          return (getAccess.apply(m) & Opcodes.ACC_PRIVATE) == 0;
        })
        .collect(Collectors.toList());

    // We just iterate through since order of each list should match
    // An IndexOutOfBoundsException may be thrown if extra or missing stubs are found
    int max = Math.max(stubbed.size(), filtered.size());
    for (int i = 0; i < max; i++) {
      assertMemberStubbedCorrectly.apply(filtered.get(i), stubbed.remove(0));
    }
  }

  private static Void assertInnerClassStubbedCorrectly(
      InnerClassNode original,
      InnerClassNode stubbed) {
    assertEquals(original.name, stubbed.name);
    assertEquals(original.outerName, stubbed.outerName);
    assertEquals(original.innerName, stubbed.innerName);
    assertEquals(original.access, stubbed.access);
    return null;
  }

  private static Void assertMethodStubbedCorrectly(MethodNode original, MethodNode stubbed) {
    assertEquals(original.access, stubbed.access);
    assertEquals(original.name, stubbed.name);
    assertEquals(original.desc, stubbed.desc);
    assertEquals(original.signature, stubbed.signature);
    assertEquals(original.exceptions, stubbed.exceptions);
    assertParametersEqual(original.parameters, stubbed.parameters);
    assertAnnotationsEqual(original.visibleAnnotations, stubbed.visibleAnnotations);
    assertAnnotationsEqual(original.invisibleAnnotations, stubbed.invisibleAnnotations);
    assertTypeAnnotationsEqual(original.visibleTypeAnnotations, stubbed.visibleTypeAnnotations);
    assertTypeAnnotationsEqual(original.invisibleTypeAnnotations, stubbed.invisibleTypeAnnotations);
    assertAnnotationValueEquals(original.annotationDefault, stubbed.annotationDefault);
    assertParameterAnnotationsEqual(
        original.visibleParameterAnnotations,
        stubbed.visibleParameterAnnotations);
    assertParameterAnnotationsEqual(
        original.invisibleParameterAnnotations,
        stubbed.invisibleParameterAnnotations);

    return null;
  }

  private static Void assertFieldStubbedCorrectly(FieldNode original, FieldNode stubbed) {
    assertEquals(original.access, stubbed.access);
    assertEquals(original.name, stubbed.name);
    assertEquals(original.desc, stubbed.desc);
    assertEquals(original.signature, stubbed.signature);
    assertEquals(original.value, stubbed.value);
    assertAnnotationsEqual(original.visibleAnnotations, stubbed.visibleAnnotations);
    assertAnnotationsEqual(original.invisibleAnnotations, stubbed.invisibleAnnotations);
    assertTypeAnnotationsEqual(original.visibleTypeAnnotations, stubbed.visibleTypeAnnotations);
    assertTypeAnnotationsEqual(original.invisibleTypeAnnotations, stubbed.invisibleTypeAnnotations);
    assertEquals(original.attrs, stubbed.attrs);

    return null;
  }

  private static void assertParameterAnnotationsEqual(
      List<AnnotationNode>[] expected,
      List<AnnotationNode>[] seen) {
    if (expected == null) {
      assertNull(seen);
      return;
    }

    assertSame(expected.length, seen.length);

    for (int i = 0; i < expected.length; i++) {
      assertAnnotationsEqual(expected[i], seen[i]);
    }
  }


  private static void assertAnnotationsEqual(
      List<AnnotationNode> expected,
      List<AnnotationNode> seen) {
    assertListsEqual(expected, seen, StubJarTest::annotationToString);
  }

  private static void assertParametersEqual(
      List<ParameterNode> expected,
      List<ParameterNode> seen) {
    assertListsEqual(expected, seen, StubJarTest::parameterToString);
  }

  private static void assertTypeAnnotationsEqual(
      List<TypeAnnotationNode> expected,
      List<TypeAnnotationNode> seen) {
    assertListsEqual(expected, seen, StubJarTest::typeAnnotationToString);
  }

  private static <T> void assertListsEqual(
      List<T> expected,
      List<T> seen,
      Function<T, String> toString) {
    if (expected == null) {
      assertNull(seen);
      return;
    }
    assertNotNull(
        String.format(
            "Stubbed no %s's",
            expected.get(0).getClass().getSimpleName()),
        seen);

    assertEquals(
        expected.stream()
            .map(toString)
            .collect(Collectors.toList()),
        seen.stream()
            .map(toString)
            .collect(Collectors.toList()));
  }

  private void assertCompilationErrors(List<String> expectedErrors) {
    List<String> actual = diagnostics.stream()
        .map(diagnostic -> diagnostic.substring(diagnostic.lastIndexOf(File.separatorChar) + 1))
        .collect(Collectors.toList());
    assertThat(actual, Matchers.containsInAnyOrder(expectedErrors.toArray()));
  }

  private static String typeAnnotationToString(TypeAnnotationNode typeAnnotationNode) {
    return String.format(
        "%d %s %s(%s)",
        typeAnnotationNode.typeRef,
        typeAnnotationNode.typePath,
        typeAnnotationNode.desc,
        annotationValuesToString(typeAnnotationNode.values));
  }

  private static String parameterToString(ParameterNode parameter) {
    return String.format("0x%x %s", parameter.access, parameter.name);
  }

  private static String annotationToString(AnnotationNode annotationNode) {
    return String.format(
        "%s(%s)",
        annotationNode.desc,
        annotationValuesToString(annotationNode.values));
  }

  private static void assertAnnotationValueEquals(Object expected, Object actual) {
    assertEquals(annotationValueToString(expected), annotationValueToString(actual));
  }

  private static String annotationValueToString(Object value) {
    if (value instanceof AnnotationNode) {
      return annotationToString((AnnotationNode) value);
    } else if (value instanceof List) {
      return annotationValuesToString((List<?>) value);
    } else if (value instanceof String[]) {
      String[] valueArray = (String[]) value;
      return String.format("%s.%s", valueArray[0], valueArray[1]);
    }

    return String.valueOf(value);
  }

  private static String annotationValuesToString(List<?> values) {
    if (values == null) {
      return "null";
    }

    StringBuilder resultBuilder = new StringBuilder();

    resultBuilder.append('[');
    for (int i = 0; i < values.size(); i++) {
      resultBuilder.append(annotationValueToString(values.get(i)));

      if (i > 0) {
        resultBuilder.append(", ");
      }
    }
    resultBuilder.append(']');
    return resultBuilder.toString();
  }

  private void notYetImplementedForMissingClasspath() {
    assumeThat(testingMode, Matchers.not(Matchers.equalTo(MODE_SOURCE_BASED_MISSING_DEPS)));
  }

  private void notYetImplementedForSource() {
    assumeThat(testingMode, Matchers.equalTo(MODE_JAR_BASED));
  }

  private void addAllowedInnerClassNames(String... allowedInnerClassNames) {
    Collections.addAll(this.allowedInnerClassNames, allowedInnerClassNames);
  }

  private static class JarPaths {
    public final Path fullJar;
    public final Path stubJar;

    public JarPaths(Path fullJar, Path stubJar) {
      this.fullJar = fullJar;
      this.stubJar = stubJar;
    }
  }
}
